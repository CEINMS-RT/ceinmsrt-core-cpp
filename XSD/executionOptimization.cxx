// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "executionOptimization.hxx"

// MuscleListOptimizationType
//

MuscleListOptimizationType::
MuscleListOptimizationType()
    : ::xsd::cxx::tree::list< ::xml_schema::string, char >(this)
{
}

MuscleListOptimizationType::
MuscleListOptimizationType(size_type n, const ::xml_schema::string& x)
    : ::xsd::cxx::tree::list< ::xml_schema::string, char >(n, x, this)
{
}

MuscleListOptimizationType::
MuscleListOptimizationType(const MuscleListOptimizationType& o,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char >(o, f, this)
{
}

// TresholdType
//

TresholdType::
TresholdType()
    : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(this)
{
}

TresholdType::
TresholdType(size_type n, const ::xml_schema::double_& x)
    : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(n, x, this)
{
}

TresholdType::
TresholdType(const TresholdType& o,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(o, f, this)
{
}

// AlgorithmSimulatedAnnealingType
// 

const AlgorithmSimulatedAnnealingType::noEpsilon_type& AlgorithmSimulatedAnnealingType::
noEpsilon() const
{
    return this->noEpsilon_.get();
}

AlgorithmSimulatedAnnealingType::noEpsilon_type& AlgorithmSimulatedAnnealingType::
noEpsilon()
{
    return this->noEpsilon_.get();
}

void AlgorithmSimulatedAnnealingType::
noEpsilon(const noEpsilon_type& x)
{
    this->noEpsilon_.set(x);
}

const AlgorithmSimulatedAnnealingType::rt_type& AlgorithmSimulatedAnnealingType::
rt() const
{
    return this->rt_.get();
}

AlgorithmSimulatedAnnealingType::rt_type& AlgorithmSimulatedAnnealingType::
rt()
{
    return this->rt_.get();
}

void AlgorithmSimulatedAnnealingType::
rt(const rt_type& x)
{
    this->rt_.set(x);
}

const AlgorithmSimulatedAnnealingType::T_type& AlgorithmSimulatedAnnealingType::
T() const
{
    return this->T_.get();
}

AlgorithmSimulatedAnnealingType::T_type& AlgorithmSimulatedAnnealingType::
T()
{
    return this->T_.get();
}

void AlgorithmSimulatedAnnealingType::
T(const T_type& x)
{
    this->T_.set(x);
}

const AlgorithmSimulatedAnnealingType::NS_type& AlgorithmSimulatedAnnealingType::
NS() const
{
    return this->NS_.get();
}

AlgorithmSimulatedAnnealingType::NS_type& AlgorithmSimulatedAnnealingType::
NS()
{
    return this->NS_.get();
}

void AlgorithmSimulatedAnnealingType::
NS(const NS_type& x)
{
    this->NS_.set(x);
}

const AlgorithmSimulatedAnnealingType::NT_type& AlgorithmSimulatedAnnealingType::
NT() const
{
    return this->NT_.get();
}

AlgorithmSimulatedAnnealingType::NT_type& AlgorithmSimulatedAnnealingType::
NT()
{
    return this->NT_.get();
}

void AlgorithmSimulatedAnnealingType::
NT(const NT_type& x)
{
    this->NT_.set(x);
}

const AlgorithmSimulatedAnnealingType::epsilon_type& AlgorithmSimulatedAnnealingType::
epsilon() const
{
    return this->epsilon_.get();
}

AlgorithmSimulatedAnnealingType::epsilon_type& AlgorithmSimulatedAnnealingType::
epsilon()
{
    return this->epsilon_.get();
}

void AlgorithmSimulatedAnnealingType::
epsilon(const epsilon_type& x)
{
    this->epsilon_.set(x);
}

const AlgorithmSimulatedAnnealingType::maxNoEval_type& AlgorithmSimulatedAnnealingType::
maxNoEval() const
{
    return this->maxNoEval_.get();
}

AlgorithmSimulatedAnnealingType::maxNoEval_type& AlgorithmSimulatedAnnealingType::
maxNoEval()
{
    return this->maxNoEval_.get();
}

void AlgorithmSimulatedAnnealingType::
maxNoEval(const maxNoEval_type& x)
{
    this->maxNoEval_.set(x);
}


// LMElementType
// 


// SimplexElementType
// 


// AlgorithmType
// 

const AlgorithmType::SimulatedAnnealing_optional& AlgorithmType::
SimulatedAnnealing() const
{
    return this->SimulatedAnnealing_;
}

AlgorithmType::SimulatedAnnealing_optional& AlgorithmType::
SimulatedAnnealing()
{
    return this->SimulatedAnnealing_;
}

void AlgorithmType::
SimulatedAnnealing(const SimulatedAnnealing_type& x)
{
    this->SimulatedAnnealing_.set(x);
}

void AlgorithmType::
SimulatedAnnealing(const SimulatedAnnealing_optional& x)
{
    this->SimulatedAnnealing_ = x;
}

void AlgorithmType::
SimulatedAnnealing(::std::auto_ptr< SimulatedAnnealing_type > x)
{
    this->SimulatedAnnealing_.set(x);
}

const AlgorithmType::LM_optional& AlgorithmType::
LM() const
{
    return this->LM_;
}

AlgorithmType::LM_optional& AlgorithmType::
LM()
{
    return this->LM_;
}

void AlgorithmType::
LM(const LM_type& x)
{
    this->LM_.set(x);
}

void AlgorithmType::
LM(const LM_optional& x)
{
    this->LM_ = x;
}

void AlgorithmType::
LM(::std::auto_ptr< LM_type > x)
{
    this->LM_.set(x);
}

const AlgorithmType::Simplex_optional& AlgorithmType::
Simplex() const
{
    return this->Simplex_;
}

AlgorithmType::Simplex_optional& AlgorithmType::
Simplex()
{
    return this->Simplex_;
}

void AlgorithmType::
Simplex(const Simplex_type& x)
{
    this->Simplex_.set(x);
}

void AlgorithmType::
Simplex(const Simplex_optional& x)
{
    this->Simplex_ = x;
}

void AlgorithmType::
Simplex(::std::auto_ptr< Simplex_type > x)
{
    this->Simplex_.set(x);
}


// MuscleInTheLoopType
// 

const MuscleInTheLoopType::trackedMuscles_type& MuscleInTheLoopType::
trackedMuscles() const
{
    return this->trackedMuscles_.get();
}

MuscleInTheLoopType::trackedMuscles_type& MuscleInTheLoopType::
trackedMuscles()
{
    return this->trackedMuscles_.get();
}

void MuscleInTheLoopType::
trackedMuscles(const trackedMuscles_type& x)
{
    this->trackedMuscles_.set(x);
}

void MuscleInTheLoopType::
trackedMuscles(::std::auto_ptr< trackedMuscles_type > x)
{
    this->trackedMuscles_.set(x);
}

const MuscleInTheLoopType::optimizedMuscles_type& MuscleInTheLoopType::
optimizedMuscles() const
{
    return this->optimizedMuscles_.get();
}

MuscleInTheLoopType::optimizedMuscles_type& MuscleInTheLoopType::
optimizedMuscles()
{
    return this->optimizedMuscles_.get();
}

void MuscleInTheLoopType::
optimizedMuscles(const optimizedMuscles_type& x)
{
    this->optimizedMuscles_.set(x);
}

void MuscleInTheLoopType::
optimizedMuscles(::std::auto_ptr< optimizedMuscles_type > x)
{
    this->optimizedMuscles_.set(x);
}

const MuscleInTheLoopType::DOFsOptimized_type& MuscleInTheLoopType::
DOFsOptimized() const
{
    return this->DOFsOptimized_.get();
}

MuscleInTheLoopType::DOFsOptimized_type& MuscleInTheLoopType::
DOFsOptimized()
{
    return this->DOFsOptimized_.get();
}

void MuscleInTheLoopType::
DOFsOptimized(const DOFsOptimized_type& x)
{
    this->DOFsOptimized_.set(x);
}

void MuscleInTheLoopType::
DOFsOptimized(::std::auto_ptr< DOFsOptimized_type > x)
{
    this->DOFsOptimized_.set(x);
}

const MuscleInTheLoopType::optimizationCriterion_type& MuscleInTheLoopType::
optimizationCriterion() const
{
    return this->optimizationCriterion_.get();
}

MuscleInTheLoopType::optimizationCriterion_type& MuscleInTheLoopType::
optimizationCriterion()
{
    return this->optimizationCriterion_.get();
}

void MuscleInTheLoopType::
optimizationCriterion(const optimizationCriterion_type& x)
{
    this->optimizationCriterion_.set(x);
}

void MuscleInTheLoopType::
optimizationCriterion(::std::auto_ptr< optimizationCriterion_type > x)
{
    this->optimizationCriterion_.set(x);
}

const MuscleInTheLoopType::wheightOptimizedMuscle_type& MuscleInTheLoopType::
wheightOptimizedMuscle() const
{
    return this->wheightOptimizedMuscle_.get();
}

MuscleInTheLoopType::wheightOptimizedMuscle_type& MuscleInTheLoopType::
wheightOptimizedMuscle()
{
    return this->wheightOptimizedMuscle_.get();
}

void MuscleInTheLoopType::
wheightOptimizedMuscle(const wheightOptimizedMuscle_type& x)
{
    this->wheightOptimizedMuscle_.set(x);
}

const MuscleInTheLoopType::wheightNonOptimizedMuscle_type& MuscleInTheLoopType::
wheightNonOptimizedMuscle() const
{
    return this->wheightNonOptimizedMuscle_.get();
}

MuscleInTheLoopType::wheightNonOptimizedMuscle_type& MuscleInTheLoopType::
wheightNonOptimizedMuscle()
{
    return this->wheightNonOptimizedMuscle_.get();
}

void MuscleInTheLoopType::
wheightNonOptimizedMuscle(const wheightNonOptimizedMuscle_type& x)
{
    this->wheightNonOptimizedMuscle_.set(x);
}

const MuscleInTheLoopType::reductionFactor_type& MuscleInTheLoopType::
reductionFactor() const
{
    return this->reductionFactor_.get();
}

MuscleInTheLoopType::reductionFactor_type& MuscleInTheLoopType::
reductionFactor()
{
    return this->reductionFactor_.get();
}

void MuscleInTheLoopType::
reductionFactor(const reductionFactor_type& x)
{
    this->reductionFactor_.set(x);
}

const MuscleInTheLoopType::nCyclesRef_type& MuscleInTheLoopType::
nCyclesRef() const
{
    return this->nCyclesRef_.get();
}

MuscleInTheLoopType::nCyclesRef_type& MuscleInTheLoopType::
nCyclesRef()
{
    return this->nCyclesRef_.get();
}

void MuscleInTheLoopType::
nCyclesRef(const nCyclesRef_type& x)
{
    this->nCyclesRef_.set(x);
}

const MuscleInTheLoopType::nCyclesOptimization_type& MuscleInTheLoopType::
nCyclesOptimization() const
{
    return this->nCyclesOptimization_.get();
}

MuscleInTheLoopType::nCyclesOptimization_type& MuscleInTheLoopType::
nCyclesOptimization()
{
    return this->nCyclesOptimization_.get();
}

void MuscleInTheLoopType::
nCyclesOptimization(const nCyclesOptimization_type& x)
{
    this->nCyclesOptimization_.set(x);
}


// HybridOptimizationType
// 

const HybridOptimizationType::alpha_type& HybridOptimizationType::
alpha() const
{
    return this->alpha_.get();
}

HybridOptimizationType::alpha_type& HybridOptimizationType::
alpha()
{
    return this->alpha_.get();
}

void HybridOptimizationType::
alpha(const alpha_type& x)
{
    this->alpha_.set(x);
}

const HybridOptimizationType::beta_type& HybridOptimizationType::
beta() const
{
    return this->beta_.get();
}

HybridOptimizationType::beta_type& HybridOptimizationType::
beta()
{
    return this->beta_.get();
}

void HybridOptimizationType::
beta(const beta_type& x)
{
    this->beta_.set(x);
}

const HybridOptimizationType::gamma_type& HybridOptimizationType::
gamma() const
{
    return this->gamma_.get();
}

HybridOptimizationType::gamma_type& HybridOptimizationType::
gamma()
{
    return this->gamma_.get();
}

void HybridOptimizationType::
gamma(const gamma_type& x)
{
    this->gamma_.set(x);
}

const HybridOptimizationType::trackedMuscles_type& HybridOptimizationType::
trackedMuscles() const
{
    return this->trackedMuscles_.get();
}

HybridOptimizationType::trackedMuscles_type& HybridOptimizationType::
trackedMuscles()
{
    return this->trackedMuscles_.get();
}

void HybridOptimizationType::
trackedMuscles(const trackedMuscles_type& x)
{
    this->trackedMuscles_.set(x);
}

void HybridOptimizationType::
trackedMuscles(::std::auto_ptr< trackedMuscles_type > x)
{
    this->trackedMuscles_.set(x);
}

const HybridOptimizationType::predictedMuscles_type& HybridOptimizationType::
predictedMuscles() const
{
    return this->predictedMuscles_.get();
}

HybridOptimizationType::predictedMuscles_type& HybridOptimizationType::
predictedMuscles()
{
    return this->predictedMuscles_.get();
}

void HybridOptimizationType::
predictedMuscles(const predictedMuscles_type& x)
{
    this->predictedMuscles_.set(x);
}

void HybridOptimizationType::
predictedMuscles(::std::auto_ptr< predictedMuscles_type > x)
{
    this->predictedMuscles_.set(x);
}

const HybridOptimizationType::DOFsOptimized_type& HybridOptimizationType::
DOFsOptimized() const
{
    return this->DOFsOptimized_.get();
}

HybridOptimizationType::DOFsOptimized_type& HybridOptimizationType::
DOFsOptimized()
{
    return this->DOFsOptimized_.get();
}

void HybridOptimizationType::
DOFsOptimized(const DOFsOptimized_type& x)
{
    this->DOFsOptimized_.set(x);
}

void HybridOptimizationType::
DOFsOptimized(::std::auto_ptr< DOFsOptimized_type > x)
{
    this->DOFsOptimized_.set(x);
}

const HybridOptimizationType::performanceCriterion_type& HybridOptimizationType::
performanceCriterion() const
{
    return this->performanceCriterion_.get();
}

HybridOptimizationType::performanceCriterion_type& HybridOptimizationType::
performanceCriterion()
{
    return this->performanceCriterion_.get();
}

void HybridOptimizationType::
performanceCriterion(const performanceCriterion_type& x)
{
    this->performanceCriterion_.set(x);
}

void HybridOptimizationType::
performanceCriterion(::std::auto_ptr< performanceCriterion_type > x)
{
    this->performanceCriterion_.set(x);
}


// OnlineCalibrationType
// 

const OnlineCalibrationType::trackedMuscles_type& OnlineCalibrationType::
trackedMuscles() const
{
    return this->trackedMuscles_.get();
}

OnlineCalibrationType::trackedMuscles_type& OnlineCalibrationType::
trackedMuscles()
{
    return this->trackedMuscles_.get();
}

void OnlineCalibrationType::
trackedMuscles(const trackedMuscles_type& x)
{
    this->trackedMuscles_.set(x);
}

void OnlineCalibrationType::
trackedMuscles(::std::auto_ptr< trackedMuscles_type > x)
{
    this->trackedMuscles_.set(x);
}

const OnlineCalibrationType::predictedMuscles_type& OnlineCalibrationType::
predictedMuscles() const
{
    return this->predictedMuscles_.get();
}

OnlineCalibrationType::predictedMuscles_type& OnlineCalibrationType::
predictedMuscles()
{
    return this->predictedMuscles_.get();
}

void OnlineCalibrationType::
predictedMuscles(const predictedMuscles_type& x)
{
    this->predictedMuscles_.set(x);
}

void OnlineCalibrationType::
predictedMuscles(::std::auto_ptr< predictedMuscles_type > x)
{
    this->predictedMuscles_.set(x);
}

const OnlineCalibrationType::BufferSize_type& OnlineCalibrationType::
BufferSize() const
{
    return this->BufferSize_.get();
}

OnlineCalibrationType::BufferSize_type& OnlineCalibrationType::
BufferSize()
{
    return this->BufferSize_.get();
}

void OnlineCalibrationType::
BufferSize(const BufferSize_type& x)
{
    this->BufferSize_.set(x);
}


// MuscleParameterType
// 

const MuscleParameterType::trackedMuscles_type& MuscleParameterType::
trackedMuscles() const
{
    return this->trackedMuscles_.get();
}

MuscleParameterType::trackedMuscles_type& MuscleParameterType::
trackedMuscles()
{
    return this->trackedMuscles_.get();
}

void MuscleParameterType::
trackedMuscles(const trackedMuscles_type& x)
{
    this->trackedMuscles_.set(x);
}

void MuscleParameterType::
trackedMuscles(::std::auto_ptr< trackedMuscles_type > x)
{
    this->trackedMuscles_.set(x);
}

const MuscleParameterType::alpha_type& MuscleParameterType::
alpha() const
{
    return this->alpha_.get();
}

MuscleParameterType::alpha_type& MuscleParameterType::
alpha()
{
    return this->alpha_.get();
}

void MuscleParameterType::
alpha(const alpha_type& x)
{
    this->alpha_.set(x);
}

const MuscleParameterType::beta_type& MuscleParameterType::
beta() const
{
    return this->beta_.get();
}

MuscleParameterType::beta_type& MuscleParameterType::
beta()
{
    return this->beta_.get();
}

void MuscleParameterType::
beta(const beta_type& x)
{
    this->beta_.set(x);
}

const MuscleParameterType::gamma_type& MuscleParameterType::
gamma() const
{
    return this->gamma_.get();
}

MuscleParameterType::gamma_type& MuscleParameterType::
gamma()
{
    return this->gamma_.get();
}

void MuscleParameterType::
gamma(const gamma_type& x)
{
    this->gamma_.set(x);
}

const MuscleParameterType::MuscleForceTreshold_type& MuscleParameterType::
MuscleForceTreshold() const
{
    return this->MuscleForceTreshold_.get();
}

MuscleParameterType::MuscleForceTreshold_type& MuscleParameterType::
MuscleForceTreshold()
{
    return this->MuscleForceTreshold_.get();
}

void MuscleParameterType::
MuscleForceTreshold(const MuscleForceTreshold_type& x)
{
    this->MuscleForceTreshold_.set(x);
}

void MuscleParameterType::
MuscleForceTreshold(::std::auto_ptr< MuscleForceTreshold_type > x)
{
    this->MuscleForceTreshold_.set(x);
}

const MuscleParameterType::MuscleLengthTreshold_type& MuscleParameterType::
MuscleLengthTreshold() const
{
    return this->MuscleLengthTreshold_.get();
}

MuscleParameterType::MuscleLengthTreshold_type& MuscleParameterType::
MuscleLengthTreshold()
{
    return this->MuscleLengthTreshold_.get();
}

void MuscleParameterType::
MuscleLengthTreshold(const MuscleLengthTreshold_type& x)
{
    this->MuscleLengthTreshold_.set(x);
}

void MuscleParameterType::
MuscleLengthTreshold(::std::auto_ptr< MuscleLengthTreshold_type > x)
{
    this->MuscleLengthTreshold_.set(x);
}


// OptimizationType
// 

const OptimizationType::Algorithm_type& OptimizationType::
Algorithm() const
{
    return this->Algorithm_.get();
}

OptimizationType::Algorithm_type& OptimizationType::
Algorithm()
{
    return this->Algorithm_.get();
}

void OptimizationType::
Algorithm(const Algorithm_type& x)
{
    this->Algorithm_.set(x);
}

void OptimizationType::
Algorithm(::std::auto_ptr< Algorithm_type > x)
{
    this->Algorithm_.set(x);
}

const OptimizationType::MuscleInTheLoop_optional& OptimizationType::
MuscleInTheLoop() const
{
    return this->MuscleInTheLoop_;
}

OptimizationType::MuscleInTheLoop_optional& OptimizationType::
MuscleInTheLoop()
{
    return this->MuscleInTheLoop_;
}

void OptimizationType::
MuscleInTheLoop(const MuscleInTheLoop_type& x)
{
    this->MuscleInTheLoop_.set(x);
}

void OptimizationType::
MuscleInTheLoop(const MuscleInTheLoop_optional& x)
{
    this->MuscleInTheLoop_ = x;
}

void OptimizationType::
MuscleInTheLoop(::std::auto_ptr< MuscleInTheLoop_type > x)
{
    this->MuscleInTheLoop_.set(x);
}

const OptimizationType::Hybrid_optional& OptimizationType::
Hybrid() const
{
    return this->Hybrid_;
}

OptimizationType::Hybrid_optional& OptimizationType::
Hybrid()
{
    return this->Hybrid_;
}

void OptimizationType::
Hybrid(const Hybrid_type& x)
{
    this->Hybrid_.set(x);
}

void OptimizationType::
Hybrid(const Hybrid_optional& x)
{
    this->Hybrid_ = x;
}

void OptimizationType::
Hybrid(::std::auto_ptr< Hybrid_type > x)
{
    this->Hybrid_.set(x);
}

const OptimizationType::OnlineCalibration_optional& OptimizationType::
OnlineCalibration() const
{
    return this->OnlineCalibration_;
}

OptimizationType::OnlineCalibration_optional& OptimizationType::
OnlineCalibration()
{
    return this->OnlineCalibration_;
}

void OptimizationType::
OnlineCalibration(const OnlineCalibration_type& x)
{
    this->OnlineCalibration_.set(x);
}

void OptimizationType::
OnlineCalibration(const OnlineCalibration_optional& x)
{
    this->OnlineCalibration_ = x;
}

void OptimizationType::
OnlineCalibration(::std::auto_ptr< OnlineCalibration_type > x)
{
    this->OnlineCalibration_.set(x);
}

const OptimizationType::MuscleParameter_optional& OptimizationType::
MuscleParameter() const
{
    return this->MuscleParameter_;
}

OptimizationType::MuscleParameter_optional& OptimizationType::
MuscleParameter()
{
    return this->MuscleParameter_;
}

void OptimizationType::
MuscleParameter(const MuscleParameter_type& x)
{
    this->MuscleParameter_.set(x);
}

void OptimizationType::
MuscleParameter(const MuscleParameter_optional& x)
{
    this->MuscleParameter_ = x;
}

void OptimizationType::
MuscleParameter(::std::auto_ptr< MuscleParameter_type > x)
{
    this->MuscleParameter_.set(x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MuscleListOptimizationType
//

MuscleListOptimizationType::
MuscleListOptimizationType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char >(e, f, this)
{
}

MuscleListOptimizationType::
MuscleListOptimizationType(const ::xercesc::DOMAttr& a,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char >(a, f, this)
{
}

MuscleListOptimizationType::
MuscleListOptimizationType(const ::std::string& s,
    const ::xercesc::DOMElement* e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::string, char >(s, e, f, this)
{
}

MuscleListOptimizationType* MuscleListOptimizationType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class MuscleListOptimizationType(*this, f, c);
}

MuscleListOptimizationType::
~MuscleListOptimizationType()
{
}

// TresholdType
//

TresholdType::
TresholdType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(e, f, this)
{
}

TresholdType::
TresholdType(const ::xercesc::DOMAttr& a,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(a, f, this)
{
}

TresholdType::
TresholdType(const ::std::string& s,
    const ::xercesc::DOMElement* e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::simple_type(s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(s, e, f, this)
{
}

TresholdType* TresholdType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class TresholdType(*this, f, c);
}

TresholdType::
~TresholdType()
{
}

// AlgorithmSimulatedAnnealingType
//

AlgorithmSimulatedAnnealingType::
AlgorithmSimulatedAnnealingType(const noEpsilon_type& noEpsilon,
    const rt_type& rt,
    const T_type& T,
    const NS_type& NS,
    const NT_type& NT,
    const epsilon_type& epsilon,
    const maxNoEval_type& maxNoEval)
    : ::xml_schema::type(),
    noEpsilon_(noEpsilon, this),
    rt_(rt, this),
    T_(T, this),
    NS_(NS, this),
    NT_(NT, this),
    epsilon_(epsilon, this),
    maxNoEval_(maxNoEval, this)
{
}

AlgorithmSimulatedAnnealingType::
AlgorithmSimulatedAnnealingType(const AlgorithmSimulatedAnnealingType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    noEpsilon_(x.noEpsilon_, f, this),
    rt_(x.rt_, f, this),
    T_(x.T_, f, this),
    NS_(x.NS_, f, this),
    NT_(x.NT_, f, this),
    epsilon_(x.epsilon_, f, this),
    maxNoEval_(x.maxNoEval_, f, this)
{
}

AlgorithmSimulatedAnnealingType::
AlgorithmSimulatedAnnealingType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    noEpsilon_(this),
    rt_(this),
    T_(this),
    NS_(this),
    NT_(this),
    epsilon_(this),
    maxNoEval_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void AlgorithmSimulatedAnnealingType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // noEpsilon
        //
        if (n.name() == "noEpsilon" && n.namespace_().empty())
        {
            if (!noEpsilon_.present())
            {
                this->noEpsilon_.set(noEpsilon_traits::create(i, f, this));
                continue;
            }
        }

        // rt
        //
        if (n.name() == "rt" && n.namespace_().empty())
        {
            if (!rt_.present())
            {
                this->rt_.set(rt_traits::create(i, f, this));
                continue;
            }
        }

        // T
        //
        if (n.name() == "T" && n.namespace_().empty())
        {
            if (!T_.present())
            {
                this->T_.set(T_traits::create(i, f, this));
                continue;
            }
        }

        // NS
        //
        if (n.name() == "NS" && n.namespace_().empty())
        {
            if (!NS_.present())
            {
                this->NS_.set(NS_traits::create(i, f, this));
                continue;
            }
        }

        // NT
        //
        if (n.name() == "NT" && n.namespace_().empty())
        {
            if (!NT_.present())
            {
                this->NT_.set(NT_traits::create(i, f, this));
                continue;
            }
        }

        // epsilon
        //
        if (n.name() == "epsilon" && n.namespace_().empty())
        {
            if (!epsilon_.present())
            {
                this->epsilon_.set(epsilon_traits::create(i, f, this));
                continue;
            }
        }

        // maxNoEval
        //
        if (n.name() == "maxNoEval" && n.namespace_().empty())
        {
            if (!maxNoEval_.present())
            {
                this->maxNoEval_.set(maxNoEval_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!noEpsilon_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "noEpsilon",
            "");
    }

    if (!rt_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "rt",
            "");
    }

    if (!T_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "T",
            "");
    }

    if (!NS_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "NS",
            "");
    }

    if (!NT_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "NT",
            "");
    }

    if (!epsilon_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "epsilon",
            "");
    }

    if (!maxNoEval_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "maxNoEval",
            "");
    }
}

AlgorithmSimulatedAnnealingType* AlgorithmSimulatedAnnealingType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class AlgorithmSimulatedAnnealingType(*this, f, c);
}

AlgorithmSimulatedAnnealingType& AlgorithmSimulatedAnnealingType::
operator= (const AlgorithmSimulatedAnnealingType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->noEpsilon_ = x.noEpsilon_;
        this->rt_ = x.rt_;
        this->T_ = x.T_;
        this->NS_ = x.NS_;
        this->NT_ = x.NT_;
        this->epsilon_ = x.epsilon_;
        this->maxNoEval_ = x.maxNoEval_;
    }

    return *this;
}

AlgorithmSimulatedAnnealingType::
~AlgorithmSimulatedAnnealingType()
{
}

// LMElementType
//

LMElementType::
LMElementType()
    : ::xml_schema::type()
{
}

LMElementType::
LMElementType(const LMElementType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c)
{
}

LMElementType::
LMElementType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c)
{
}

LMElementType::
LMElementType(const ::xercesc::DOMAttr& a,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c)
{
}

LMElementType::
LMElementType(const ::std::string& s,
    const ::xercesc::DOMElement* e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c)
{
}

LMElementType* LMElementType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class LMElementType(*this, f, c);
}

LMElementType::
~LMElementType()
{
}

// SimplexElementType
//

SimplexElementType::
SimplexElementType()
    : ::xml_schema::type()
{
}

SimplexElementType::
SimplexElementType(const SimplexElementType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c)
{
}

SimplexElementType::
SimplexElementType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c)
{
}

SimplexElementType::
SimplexElementType(const ::xercesc::DOMAttr& a,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c)
{
}

SimplexElementType::
SimplexElementType(const ::std::string& s,
    const ::xercesc::DOMElement* e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c)
{
}

SimplexElementType* SimplexElementType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class SimplexElementType(*this, f, c);
}

SimplexElementType::
~SimplexElementType()
{
}

// AlgorithmType
//

AlgorithmType::
AlgorithmType()
    : ::xml_schema::type(),
    SimulatedAnnealing_(this),
    LM_(this),
    Simplex_(this)
{
}

AlgorithmType::
AlgorithmType(const AlgorithmType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    SimulatedAnnealing_(x.SimulatedAnnealing_, f, this),
    LM_(x.LM_, f, this),
    Simplex_(x.Simplex_, f, this)
{
}

AlgorithmType::
AlgorithmType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    SimulatedAnnealing_(this),
    LM_(this),
    Simplex_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void AlgorithmType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // SimulatedAnnealing
        //
        if (n.name() == "SimulatedAnnealing" && n.namespace_().empty())
        {
            ::std::auto_ptr< SimulatedAnnealing_type > r(
                SimulatedAnnealing_traits::create(i, f, this));

            if (!this->SimulatedAnnealing_)
            {
                this->SimulatedAnnealing_.set(r);
                continue;
            }
        }

        // LM
        //
        if (n.name() == "LM" && n.namespace_().empty())
        {
            ::std::auto_ptr< LM_type > r(
                LM_traits::create(i, f, this));

            if (!this->LM_)
            {
                this->LM_.set(r);
                continue;
            }
        }

        // Simplex
        //
        if (n.name() == "Simplex" && n.namespace_().empty())
        {
            ::std::auto_ptr< Simplex_type > r(
                Simplex_traits::create(i, f, this));

            if (!this->Simplex_)
            {
                this->Simplex_.set(r);
                continue;
            }
        }

        break;
    }
}

AlgorithmType* AlgorithmType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class AlgorithmType(*this, f, c);
}

AlgorithmType& AlgorithmType::
operator= (const AlgorithmType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->SimulatedAnnealing_ = x.SimulatedAnnealing_;
        this->LM_ = x.LM_;
        this->Simplex_ = x.Simplex_;
    }

    return *this;
}

AlgorithmType::
~AlgorithmType()
{
}

// MuscleInTheLoopType
//

MuscleInTheLoopType::
MuscleInTheLoopType(const trackedMuscles_type& trackedMuscles,
    const optimizedMuscles_type& optimizedMuscles,
    const DOFsOptimized_type& DOFsOptimized,
    const optimizationCriterion_type& optimizationCriterion,
    const wheightOptimizedMuscle_type& wheightOptimizedMuscle,
    const wheightNonOptimizedMuscle_type& wheightNonOptimizedMuscle,
    const reductionFactor_type& reductionFactor,
    const nCyclesRef_type& nCyclesRef,
    const nCyclesOptimization_type& nCyclesOptimization)
    : ::xml_schema::type(),
    trackedMuscles_(trackedMuscles, this),
    optimizedMuscles_(optimizedMuscles, this),
    DOFsOptimized_(DOFsOptimized, this),
    optimizationCriterion_(optimizationCriterion, this),
    wheightOptimizedMuscle_(wheightOptimizedMuscle, this),
    wheightNonOptimizedMuscle_(wheightNonOptimizedMuscle, this),
    reductionFactor_(reductionFactor, this),
    nCyclesRef_(nCyclesRef, this),
    nCyclesOptimization_(nCyclesOptimization, this)
{
}

MuscleInTheLoopType::
MuscleInTheLoopType(const MuscleInTheLoopType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    trackedMuscles_(x.trackedMuscles_, f, this),
    optimizedMuscles_(x.optimizedMuscles_, f, this),
    DOFsOptimized_(x.DOFsOptimized_, f, this),
    optimizationCriterion_(x.optimizationCriterion_, f, this),
    wheightOptimizedMuscle_(x.wheightOptimizedMuscle_, f, this),
    wheightNonOptimizedMuscle_(x.wheightNonOptimizedMuscle_, f, this),
    reductionFactor_(x.reductionFactor_, f, this),
    nCyclesRef_(x.nCyclesRef_, f, this),
    nCyclesOptimization_(x.nCyclesOptimization_, f, this)
{
}

MuscleInTheLoopType::
MuscleInTheLoopType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    trackedMuscles_(this),
    optimizedMuscles_(this),
    DOFsOptimized_(this),
    optimizationCriterion_(this),
    wheightOptimizedMuscle_(this),
    wheightNonOptimizedMuscle_(this),
    reductionFactor_(this),
    nCyclesRef_(this),
    nCyclesOptimization_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void MuscleInTheLoopType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // trackedMuscles
        //
        if (n.name() == "trackedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< trackedMuscles_type > r(
                trackedMuscles_traits::create(i, f, this));

            if (!trackedMuscles_.present())
            {
                this->trackedMuscles_.set(r);
                continue;
            }
        }

        // optimizedMuscles
        //
        if (n.name() == "optimizedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< optimizedMuscles_type > r(
                optimizedMuscles_traits::create(i, f, this));

            if (!optimizedMuscles_.present())
            {
                this->optimizedMuscles_.set(r);
                continue;
            }
        }

        // DOFsOptimized
        //
        if (n.name() == "DOFsOptimized" && n.namespace_().empty())
        {
            ::std::auto_ptr< DOFsOptimized_type > r(
                DOFsOptimized_traits::create(i, f, this));

            if (!DOFsOptimized_.present())
            {
                this->DOFsOptimized_.set(r);
                continue;
            }
        }

        // optimizationCriterion
        //
        if (n.name() == "optimizationCriterion" && n.namespace_().empty())
        {
            ::std::auto_ptr< optimizationCriterion_type > r(
                optimizationCriterion_traits::create(i, f, this));

            if (!optimizationCriterion_.present())
            {
                this->optimizationCriterion_.set(r);
                continue;
            }
        }

        // wheightOptimizedMuscle
        //
        if (n.name() == "wheightOptimizedMuscle" && n.namespace_().empty())
        {
            if (!wheightOptimizedMuscle_.present())
            {
                this->wheightOptimizedMuscle_.set(wheightOptimizedMuscle_traits::create(i, f, this));
                continue;
            }
        }

        // wheightNonOptimizedMuscle
        //
        if (n.name() == "wheightNonOptimizedMuscle" && n.namespace_().empty())
        {
            if (!wheightNonOptimizedMuscle_.present())
            {
                this->wheightNonOptimizedMuscle_.set(wheightNonOptimizedMuscle_traits::create(i, f, this));
                continue;
            }
        }

        // reductionFactor
        //
        if (n.name() == "reductionFactor" && n.namespace_().empty())
        {
            if (!reductionFactor_.present())
            {
                this->reductionFactor_.set(reductionFactor_traits::create(i, f, this));
                continue;
            }
        }

        // nCyclesRef
        //
        if (n.name() == "nCyclesRef" && n.namespace_().empty())
        {
            if (!nCyclesRef_.present())
            {
                this->nCyclesRef_.set(nCyclesRef_traits::create(i, f, this));
                continue;
            }
        }

        // nCyclesOptimization
        //
        if (n.name() == "nCyclesOptimization" && n.namespace_().empty())
        {
            if (!nCyclesOptimization_.present())
            {
                this->nCyclesOptimization_.set(nCyclesOptimization_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!trackedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "trackedMuscles",
            "");
    }

    if (!optimizedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "optimizedMuscles",
            "");
    }

    if (!DOFsOptimized_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "DOFsOptimized",
            "");
    }

    if (!optimizationCriterion_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "optimizationCriterion",
            "");
    }

    if (!wheightOptimizedMuscle_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "wheightOptimizedMuscle",
            "");
    }

    if (!wheightNonOptimizedMuscle_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "wheightNonOptimizedMuscle",
            "");
    }

    if (!reductionFactor_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "reductionFactor",
            "");
    }

    if (!nCyclesRef_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "nCyclesRef",
            "");
    }

    if (!nCyclesOptimization_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "nCyclesOptimization",
            "");
    }
}

MuscleInTheLoopType* MuscleInTheLoopType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class MuscleInTheLoopType(*this, f, c);
}

MuscleInTheLoopType& MuscleInTheLoopType::
operator= (const MuscleInTheLoopType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->trackedMuscles_ = x.trackedMuscles_;
        this->optimizedMuscles_ = x.optimizedMuscles_;
        this->DOFsOptimized_ = x.DOFsOptimized_;
        this->optimizationCriterion_ = x.optimizationCriterion_;
        this->wheightOptimizedMuscle_ = x.wheightOptimizedMuscle_;
        this->wheightNonOptimizedMuscle_ = x.wheightNonOptimizedMuscle_;
        this->reductionFactor_ = x.reductionFactor_;
        this->nCyclesRef_ = x.nCyclesRef_;
        this->nCyclesOptimization_ = x.nCyclesOptimization_;
    }

    return *this;
}

MuscleInTheLoopType::
~MuscleInTheLoopType()
{
}

// HybridOptimizationType
//

HybridOptimizationType::
HybridOptimizationType(const alpha_type& alpha,
    const beta_type& beta,
    const gamma_type& gamma,
    const trackedMuscles_type& trackedMuscles,
    const predictedMuscles_type& predictedMuscles,
    const DOFsOptimized_type& DOFsOptimized,
    const performanceCriterion_type& performanceCriterion)
    : ::xml_schema::type(),
    alpha_(alpha, this),
    beta_(beta, this),
    gamma_(gamma, this),
    trackedMuscles_(trackedMuscles, this),
    predictedMuscles_(predictedMuscles, this),
    DOFsOptimized_(DOFsOptimized, this),
    performanceCriterion_(performanceCriterion, this)
{
}

HybridOptimizationType::
HybridOptimizationType(const HybridOptimizationType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    alpha_(x.alpha_, f, this),
    beta_(x.beta_, f, this),
    gamma_(x.gamma_, f, this),
    trackedMuscles_(x.trackedMuscles_, f, this),
    predictedMuscles_(x.predictedMuscles_, f, this),
    DOFsOptimized_(x.DOFsOptimized_, f, this),
    performanceCriterion_(x.performanceCriterion_, f, this)
{
}

HybridOptimizationType::
HybridOptimizationType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    alpha_(this),
    beta_(this),
    gamma_(this),
    trackedMuscles_(this),
    predictedMuscles_(this),
    DOFsOptimized_(this),
    performanceCriterion_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void HybridOptimizationType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // alpha
        //
        if (n.name() == "alpha" && n.namespace_().empty())
        {
            if (!alpha_.present())
            {
                this->alpha_.set(alpha_traits::create(i, f, this));
                continue;
            }
        }

        // beta
        //
        if (n.name() == "beta" && n.namespace_().empty())
        {
            if (!beta_.present())
            {
                this->beta_.set(beta_traits::create(i, f, this));
                continue;
            }
        }

        // gamma
        //
        if (n.name() == "gamma" && n.namespace_().empty())
        {
            if (!gamma_.present())
            {
                this->gamma_.set(gamma_traits::create(i, f, this));
                continue;
            }
        }

        // trackedMuscles
        //
        if (n.name() == "trackedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< trackedMuscles_type > r(
                trackedMuscles_traits::create(i, f, this));

            if (!trackedMuscles_.present())
            {
                this->trackedMuscles_.set(r);
                continue;
            }
        }

        // predictedMuscles
        //
        if (n.name() == "predictedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< predictedMuscles_type > r(
                predictedMuscles_traits::create(i, f, this));

            if (!predictedMuscles_.present())
            {
                this->predictedMuscles_.set(r);
                continue;
            }
        }

        // DOFsOptimized
        //
        if (n.name() == "DOFsOptimized" && n.namespace_().empty())
        {
            ::std::auto_ptr< DOFsOptimized_type > r(
                DOFsOptimized_traits::create(i, f, this));

            if (!DOFsOptimized_.present())
            {
                this->DOFsOptimized_.set(r);
                continue;
            }
        }

        // performanceCriterion
        //
        if (n.name() == "performanceCriterion" && n.namespace_().empty())
        {
            ::std::auto_ptr< performanceCriterion_type > r(
                performanceCriterion_traits::create(i, f, this));

            if (!performanceCriterion_.present())
            {
                this->performanceCriterion_.set(r);
                continue;
            }
        }

        break;
    }

    if (!alpha_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "alpha",
            "");
    }

    if (!beta_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "beta",
            "");
    }

    if (!gamma_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "gamma",
            "");
    }

    if (!trackedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "trackedMuscles",
            "");
    }

    if (!predictedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "predictedMuscles",
            "");
    }

    if (!DOFsOptimized_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "DOFsOptimized",
            "");
    }

    if (!performanceCriterion_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "performanceCriterion",
            "");
    }
}

HybridOptimizationType* HybridOptimizationType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class HybridOptimizationType(*this, f, c);
}

HybridOptimizationType& HybridOptimizationType::
operator= (const HybridOptimizationType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->alpha_ = x.alpha_;
        this->beta_ = x.beta_;
        this->gamma_ = x.gamma_;
        this->trackedMuscles_ = x.trackedMuscles_;
        this->predictedMuscles_ = x.predictedMuscles_;
        this->DOFsOptimized_ = x.DOFsOptimized_;
        this->performanceCriterion_ = x.performanceCriterion_;
    }

    return *this;
}

HybridOptimizationType::
~HybridOptimizationType()
{
}

// OnlineCalibrationType
//

OnlineCalibrationType::
OnlineCalibrationType(const trackedMuscles_type& trackedMuscles,
    const predictedMuscles_type& predictedMuscles,
    const BufferSize_type& BufferSize)
    : ::xml_schema::type(),
    trackedMuscles_(trackedMuscles, this),
    predictedMuscles_(predictedMuscles, this),
    BufferSize_(BufferSize, this)
{
}

OnlineCalibrationType::
OnlineCalibrationType(const OnlineCalibrationType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    trackedMuscles_(x.trackedMuscles_, f, this),
    predictedMuscles_(x.predictedMuscles_, f, this),
    BufferSize_(x.BufferSize_, f, this)
{
}

OnlineCalibrationType::
OnlineCalibrationType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    trackedMuscles_(this),
    predictedMuscles_(this),
    BufferSize_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void OnlineCalibrationType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // trackedMuscles
        //
        if (n.name() == "trackedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< trackedMuscles_type > r(
                trackedMuscles_traits::create(i, f, this));

            if (!trackedMuscles_.present())
            {
                this->trackedMuscles_.set(r);
                continue;
            }
        }

        // predictedMuscles
        //
        if (n.name() == "predictedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< predictedMuscles_type > r(
                predictedMuscles_traits::create(i, f, this));

            if (!predictedMuscles_.present())
            {
                this->predictedMuscles_.set(r);
                continue;
            }
        }

        // BufferSize
        //
        if (n.name() == "BufferSize" && n.namespace_().empty())
        {
            if (!BufferSize_.present())
            {
                this->BufferSize_.set(BufferSize_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!trackedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "trackedMuscles",
            "");
    }

    if (!predictedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "predictedMuscles",
            "");
    }

    if (!BufferSize_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "BufferSize",
            "");
    }
}

OnlineCalibrationType* OnlineCalibrationType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class OnlineCalibrationType(*this, f, c);
}

OnlineCalibrationType& OnlineCalibrationType::
operator= (const OnlineCalibrationType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->trackedMuscles_ = x.trackedMuscles_;
        this->predictedMuscles_ = x.predictedMuscles_;
        this->BufferSize_ = x.BufferSize_;
    }

    return *this;
}

OnlineCalibrationType::
~OnlineCalibrationType()
{
}

// MuscleParameterType
//

MuscleParameterType::
MuscleParameterType(const trackedMuscles_type& trackedMuscles,
    const alpha_type& alpha,
    const beta_type& beta,
    const gamma_type& gamma,
    const MuscleForceTreshold_type& MuscleForceTreshold,
    const MuscleLengthTreshold_type& MuscleLengthTreshold)
    : ::xml_schema::type(),
    trackedMuscles_(trackedMuscles, this),
    alpha_(alpha, this),
    beta_(beta, this),
    gamma_(gamma, this),
    MuscleForceTreshold_(MuscleForceTreshold, this),
    MuscleLengthTreshold_(MuscleLengthTreshold, this)
{
}

MuscleParameterType::
MuscleParameterType(const MuscleParameterType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    trackedMuscles_(x.trackedMuscles_, f, this),
    alpha_(x.alpha_, f, this),
    beta_(x.beta_, f, this),
    gamma_(x.gamma_, f, this),
    MuscleForceTreshold_(x.MuscleForceTreshold_, f, this),
    MuscleLengthTreshold_(x.MuscleLengthTreshold_, f, this)
{
}

MuscleParameterType::
MuscleParameterType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    trackedMuscles_(this),
    alpha_(this),
    beta_(this),
    gamma_(this),
    MuscleForceTreshold_(this),
    MuscleLengthTreshold_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void MuscleParameterType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // trackedMuscles
        //
        if (n.name() == "trackedMuscles" && n.namespace_().empty())
        {
            ::std::auto_ptr< trackedMuscles_type > r(
                trackedMuscles_traits::create(i, f, this));

            if (!trackedMuscles_.present())
            {
                this->trackedMuscles_.set(r);
                continue;
            }
        }

        // alpha
        //
        if (n.name() == "alpha" && n.namespace_().empty())
        {
            if (!alpha_.present())
            {
                this->alpha_.set(alpha_traits::create(i, f, this));
                continue;
            }
        }

        // beta
        //
        if (n.name() == "beta" && n.namespace_().empty())
        {
            if (!beta_.present())
            {
                this->beta_.set(beta_traits::create(i, f, this));
                continue;
            }
        }

        // gamma
        //
        if (n.name() == "gamma" && n.namespace_().empty())
        {
            if (!gamma_.present())
            {
                this->gamma_.set(gamma_traits::create(i, f, this));
                continue;
            }
        }

        // MuscleForceTreshold
        //
        if (n.name() == "MuscleForceTreshold" && n.namespace_().empty())
        {
            ::std::auto_ptr< MuscleForceTreshold_type > r(
                MuscleForceTreshold_traits::create(i, f, this));

            if (!MuscleForceTreshold_.present())
            {
                this->MuscleForceTreshold_.set(r);
                continue;
            }
        }

        // MuscleLengthTreshold
        //
        if (n.name() == "MuscleLengthTreshold" && n.namespace_().empty())
        {
            ::std::auto_ptr< MuscleLengthTreshold_type > r(
                MuscleLengthTreshold_traits::create(i, f, this));

            if (!MuscleLengthTreshold_.present())
            {
                this->MuscleLengthTreshold_.set(r);
                continue;
            }
        }

        break;
    }

    if (!trackedMuscles_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "trackedMuscles",
            "");
    }

    if (!alpha_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "alpha",
            "");
    }

    if (!beta_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "beta",
            "");
    }

    if (!gamma_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "gamma",
            "");
    }

    if (!MuscleForceTreshold_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "MuscleForceTreshold",
            "");
    }

    if (!MuscleLengthTreshold_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "MuscleLengthTreshold",
            "");
    }
}

MuscleParameterType* MuscleParameterType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class MuscleParameterType(*this, f, c);
}

MuscleParameterType& MuscleParameterType::
operator= (const MuscleParameterType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->trackedMuscles_ = x.trackedMuscles_;
        this->alpha_ = x.alpha_;
        this->beta_ = x.beta_;
        this->gamma_ = x.gamma_;
        this->MuscleForceTreshold_ = x.MuscleForceTreshold_;
        this->MuscleLengthTreshold_ = x.MuscleLengthTreshold_;
    }

    return *this;
}

MuscleParameterType::
~MuscleParameterType()
{
}

// OptimizationType
//

OptimizationType::
OptimizationType(const Algorithm_type& Algorithm)
    : ::xml_schema::type(),
    Algorithm_(Algorithm, this),
    MuscleInTheLoop_(this),
    Hybrid_(this),
    OnlineCalibration_(this),
    MuscleParameter_(this)
{
}

OptimizationType::
OptimizationType(::std::auto_ptr< Algorithm_type > Algorithm)
    : ::xml_schema::type(),
    Algorithm_(Algorithm, this),
    MuscleInTheLoop_(this),
    Hybrid_(this),
    OnlineCalibration_(this),
    MuscleParameter_(this)
{
}

OptimizationType::
OptimizationType(const OptimizationType& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
    Algorithm_(x.Algorithm_, f, this),
    MuscleInTheLoop_(x.MuscleInTheLoop_, f, this),
    Hybrid_(x.Hybrid_, f, this),
    OnlineCalibration_(x.OnlineCalibration_, f, this),
    MuscleParameter_(x.MuscleParameter_, f, this)
{
}

OptimizationType::
OptimizationType(const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
    Algorithm_(this),
    MuscleInTheLoop_(this),
    Hybrid_(this),
    OnlineCalibration_(this),
    MuscleParameter_(this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p(e, true, false, false);
        this->parse(p, f);
    }
}

void OptimizationType::
parse(::xsd::cxx::xml::dom::parser< char >& p,
    ::xml_schema::flags f)
{
    for (; p.more_content(); p.next_content(false))
    {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name< char > n(
            ::xsd::cxx::xml::dom::name< char >(i));

        // Algorithm
        //
        if (n.name() == "Algorithm" && n.namespace_().empty())
        {
            ::std::auto_ptr< Algorithm_type > r(
                Algorithm_traits::create(i, f, this));

            if (!Algorithm_.present())
            {
                this->Algorithm_.set(r);
                continue;
            }
        }

        // MuscleInTheLoop
        //
        if (n.name() == "MuscleInTheLoop" && n.namespace_().empty())
        {
            ::std::auto_ptr< MuscleInTheLoop_type > r(
                MuscleInTheLoop_traits::create(i, f, this));

            if (!this->MuscleInTheLoop_)
            {
                this->MuscleInTheLoop_.set(r);
                continue;
            }
        }

        // Hybrid
        //
        if (n.name() == "Hybrid" && n.namespace_().empty())
        {
            ::std::auto_ptr< Hybrid_type > r(
                Hybrid_traits::create(i, f, this));

            if (!this->Hybrid_)
            {
                this->Hybrid_.set(r);
                continue;
            }
        }

        // OnlineCalibration
        //
        if (n.name() == "OnlineCalibration" && n.namespace_().empty())
        {
            ::std::auto_ptr< OnlineCalibration_type > r(
                OnlineCalibration_traits::create(i, f, this));

            if (!this->OnlineCalibration_)
            {
                this->OnlineCalibration_.set(r);
                continue;
            }
        }

        // MuscleParameter
        //
        if (n.name() == "MuscleParameter" && n.namespace_().empty())
        {
            ::std::auto_ptr< MuscleParameter_type > r(
                MuscleParameter_traits::create(i, f, this));

            if (!this->MuscleParameter_)
            {
                this->MuscleParameter_.set(r);
                continue;
            }
        }

        break;
    }

    if (!Algorithm_.present())
    {
        throw ::xsd::cxx::tree::expected_element< char >(
            "Algorithm",
            "");
    }
}

OptimizationType* OptimizationType::
_clone(::xml_schema::flags f,
    ::xml_schema::container* c) const
{
    return new class OptimizationType(*this, f, c);
}

OptimizationType& OptimizationType::
operator= (const OptimizationType& x)
{
    if (this != &x)
    {
        static_cast<::xml_schema::type&> (*this) = x;
        this->Algorithm_ = x.Algorithm_;
        this->MuscleInTheLoop_ = x.MuscleInTheLoop_;
        this->Hybrid_ = x.Hybrid_;
        this->OnlineCalibration_ = x.OnlineCalibration_;
        this->MuscleParameter_ = x.MuscleParameter_;
    }

    return *this;
}

OptimizationType::
~OptimizationType()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& u,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& u,
    ::xml_schema::error_handler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            u, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing< char >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& u,
    ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            u, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing< char >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::optimization(isrc, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xml_schema::error_handler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::optimization(isrc, h, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::optimization(isrc, h, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& sid,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::optimization(isrc, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& sid,
    ::xml_schema::error_handler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::auto_initializer i(
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::optimization(isrc, h, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& sid,
    ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::optimization(isrc, h, f, p);
}

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& i,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& i,
    ::xml_schema::error_handler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            i, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing< char >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& i,
    ::xercesc::DOMErrorHandler& h,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
        ::xsd::cxx::xml::dom::parse< char >(
            i, h, p, f));

    if (!d.get())
        throw ::xsd::cxx::tree::parsing< char >();

    return ::std::auto_ptr< ::OptimizationType >(
        ::optimization(
            d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::OptimizationType >
optimization(const ::xercesc::DOMDocument& doc,
    ::xml_schema::flags f,
    const ::xml_schema::properties& p)
{
    if (f & ::xml_schema::flags::keep_dom)
    {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d(
            static_cast<::xercesc::DOMDocument*> (doc.cloneNode(true)));

        return ::std::auto_ptr< ::OptimizationType >(
            ::optimization(
                d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e(*doc.getDocumentElement());
    const ::xsd::cxx::xml::qualified_name< char > n(
        ::xsd::cxx::xml::dom::name< char >(e));

    if (n.name() == "optimization" &&
        n.namespace_() == "")
    {
        ::std::auto_ptr< ::OptimizationType > r(
            ::xsd::cxx::tree::traits< ::OptimizationType, char >::create(
                e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char >(
        n.name(),
        n.namespace_(),
        "optimization",
        "");
}

::std::auto_ptr< ::OptimizationType >
optimization(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
    ::xml_schema::flags f,
    const ::xml_schema::properties&)
{
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c(
        ((f & ::xml_schema::flags::keep_dom) &&
            !(f & ::xml_schema::flags::own_dom))
        ? static_cast<::xercesc::DOMDocument*> (d->cloneNode(true))
        : 0);

    ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
    const ::xercesc::DOMElement& e(*doc.getDocumentElement());

    const ::xsd::cxx::xml::qualified_name< char > n(
        ::xsd::cxx::xml::dom::name< char >(e));

    if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData(::xml_schema::dom::tree_node_key,
            (c.get() ? &c : &d),
            0);

    if (n.name() == "optimization" &&
        n.namespace_() == "")
    {
        ::std::auto_ptr< ::OptimizationType > r(
            ::xsd::cxx::tree::traits< ::OptimizationType, char >::create(
                e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char >(
        n.name(),
        n.namespace_(),
        "optimization",
        "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

