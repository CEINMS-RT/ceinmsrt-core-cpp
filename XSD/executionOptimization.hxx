// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX__EXECUTION_OPTIMIZATION_HXX
#define CXX__EXECUTION_OPTIMIZATION_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
    // anyType and anySimpleType.
    //
    typedef ::xsd::cxx::tree::type type;
    typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
    typedef ::xsd::cxx::tree::type container;

    // 8-bit
    //
    typedef signed char byte;
    typedef unsigned char unsigned_byte;

    // 16-bit
    //
    typedef short short_;
    typedef unsigned short unsigned_short;

    // 32-bit
    //
    typedef int int_;
    typedef unsigned int unsigned_int;

    // 64-bit
    //
    typedef long long long_;
    typedef unsigned long long unsigned_long;

    // Supposed to be arbitrary-length integral types.
    //
    typedef long long integer;
    typedef long long non_positive_integer;
    typedef unsigned long long non_negative_integer;
    typedef unsigned long long positive_integer;
    typedef long long negative_integer;

    // Boolean.
    //
    typedef bool boolean;

    // Floating-point types.
    //
    typedef float float_;
    typedef double double_;
    typedef double decimal;

    // String types.
    //
    typedef ::xsd::cxx::tree::string< char, simple_type > string;
    typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
    typedef ::xsd::cxx::tree::token< char, normalized_string > token;
    typedef ::xsd::cxx::tree::name< char, token > name;
    typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
    typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
    typedef ::xsd::cxx::tree::ncname< char, name > ncname;
    typedef ::xsd::cxx::tree::language< char, token > language;

    // ID/IDREF.
    //
    typedef ::xsd::cxx::tree::id< char, ncname > id;
    typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
    typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

    // URI.
    //
    typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

    // Qualified name.
    //
    typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

    // Binary.
    //
    typedef ::xsd::cxx::tree::buffer< char > buffer;
    typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
    typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

    // Date/time.
    //
    typedef ::xsd::cxx::tree::time_zone time_zone;
    typedef ::xsd::cxx::tree::date< char, simple_type > date;
    typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
    typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
    typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
    typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
    typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
    typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
    typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
    typedef ::xsd::cxx::tree::time< char, simple_type > time;

    // Entity.
    //
    typedef ::xsd::cxx::tree::entity< char, ncname > entity;
    typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

    typedef ::xsd::cxx::tree::content_order content_order;
    // Flags and properties.
    //
    typedef ::xsd::cxx::tree::flags flags;
    typedef ::xsd::cxx::tree::properties< char > properties;

    // Parsing/serialization diagnostics.
    //
    typedef ::xsd::cxx::tree::severity severity;
    typedef ::xsd::cxx::tree::error< char > error;
    typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

    // Exceptions.
    //
    typedef ::xsd::cxx::tree::exception< char > exception;
    typedef ::xsd::cxx::tree::bounds< char > bounds;
    typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
    typedef ::xsd::cxx::tree::parsing< char > parsing;
    typedef ::xsd::cxx::tree::expected_element< char > expected_element;
    typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
    typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
    typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
    typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
    typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

    // Error handler callback interface.
    //
    typedef ::xsd::cxx::xml::error_handler< char > error_handler;

    // DOM interaction.
    //
    namespace dom
    {
        // Automatic pointer for DOMDocument.
        //
        using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
        // DOM user data key for back pointers to tree nodes.
        //
        const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
    }
}

// Forward declarations.
//
class MuscleListOptimizationType;
class TresholdType;
class AlgorithmSimulatedAnnealingType;
class LMElementType;
class SimplexElementType;
class AlgorithmType;
class MuscleInTheLoopType;
class HybridOptimizationType;
class OnlineCalibrationType;
class MuscleParameterType;
class OptimizationType;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class MuscleListOptimizationType : public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::string, char >
{
public:
    MuscleListOptimizationType();

    MuscleListOptimizationType(size_type n, const ::xml_schema::string& x);

    template < typename I >
    MuscleListOptimizationType(const I& begin, const I& end)
        : ::xsd::cxx::tree::list< ::xml_schema::string, char >(begin, end, this)
    {
    }

    MuscleListOptimizationType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    MuscleListOptimizationType(const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    MuscleListOptimizationType(const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    MuscleListOptimizationType(const MuscleListOptimizationType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual MuscleListOptimizationType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual
        ~MuscleListOptimizationType();
};

class TresholdType : public ::xml_schema::simple_type,
    public ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >
{
public:
    TresholdType();

    TresholdType(size_type n, const ::xml_schema::double_& x);

    template < typename I >
    TresholdType(const I& begin, const I& end)
        : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >(begin, end, this)
    {
    }

    TresholdType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    TresholdType(const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    TresholdType(const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    TresholdType(const TresholdType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual TresholdType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual
        ~TresholdType();
};

class AlgorithmSimulatedAnnealingType : public ::xml_schema::type
{
public:
    // noEpsilon
    //
    typedef ::xml_schema::int_ noEpsilon_type;
    typedef ::xsd::cxx::tree::traits< noEpsilon_type, char > noEpsilon_traits;

    const noEpsilon_type&
        noEpsilon() const;

    noEpsilon_type&
        noEpsilon();

    void
        noEpsilon(const noEpsilon_type& x);

    // rt
    //
    typedef ::xml_schema::double_ rt_type;
    typedef ::xsd::cxx::tree::traits< rt_type, char, ::xsd::cxx::tree::schema_type::double_ > rt_traits;

    const rt_type&
        rt() const;

    rt_type&
        rt();

    void
        rt(const rt_type& x);

    // T
    //
    typedef ::xml_schema::double_ T_type;
    typedef ::xsd::cxx::tree::traits< T_type, char, ::xsd::cxx::tree::schema_type::double_ > T_traits;

    const T_type&
        T() const;

    T_type&
        T();

    void
        T(const T_type& x);

    // NS
    //
    typedef ::xml_schema::int_ NS_type;
    typedef ::xsd::cxx::tree::traits< NS_type, char > NS_traits;

    const NS_type&
        NS() const;

    NS_type&
        NS();

    void
        NS(const NS_type& x);

    // NT
    //
    typedef ::xml_schema::int_ NT_type;
    typedef ::xsd::cxx::tree::traits< NT_type, char > NT_traits;

    const NT_type&
        NT() const;

    NT_type&
        NT();

    void
        NT(const NT_type& x);

    // epsilon
    //
    typedef ::xml_schema::double_ epsilon_type;
    typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

    const epsilon_type&
        epsilon() const;

    epsilon_type&
        epsilon();

    void
        epsilon(const epsilon_type& x);

    // maxNoEval
    //
    typedef ::xml_schema::int_ maxNoEval_type;
    typedef ::xsd::cxx::tree::traits< maxNoEval_type, char > maxNoEval_traits;

    const maxNoEval_type&
        maxNoEval() const;

    maxNoEval_type&
        maxNoEval();

    void
        maxNoEval(const maxNoEval_type& x);

    // Constructors.
    //
    AlgorithmSimulatedAnnealingType(const noEpsilon_type&,
        const rt_type&,
        const T_type&,
        const NS_type&,
        const NT_type&,
        const epsilon_type&,
        const maxNoEval_type&);

    AlgorithmSimulatedAnnealingType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    AlgorithmSimulatedAnnealingType(const AlgorithmSimulatedAnnealingType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual AlgorithmSimulatedAnnealingType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AlgorithmSimulatedAnnealingType&
        operator= (const AlgorithmSimulatedAnnealingType& x);

    virtual
        ~AlgorithmSimulatedAnnealingType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< noEpsilon_type > noEpsilon_;
    ::xsd::cxx::tree::one< rt_type > rt_;
    ::xsd::cxx::tree::one< T_type > T_;
    ::xsd::cxx::tree::one< NS_type > NS_;
    ::xsd::cxx::tree::one< NT_type > NT_;
    ::xsd::cxx::tree::one< epsilon_type > epsilon_;
    ::xsd::cxx::tree::one< maxNoEval_type > maxNoEval_;
};

class LMElementType : public ::xml_schema::type
{
public:
    // Constructors.
    //
    LMElementType();

    LMElementType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    LMElementType(const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    LMElementType(const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    LMElementType(const LMElementType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual LMElementType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual
        ~LMElementType();
};

class SimplexElementType : public ::xml_schema::type
{
public:
    // Constructors.
    //
    SimplexElementType();

    SimplexElementType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    SimplexElementType(const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    SimplexElementType(const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    SimplexElementType(const SimplexElementType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual SimplexElementType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual
        ~SimplexElementType();
};

class AlgorithmType : public ::xml_schema::type
{
public:
    // SimulatedAnnealing
    //
    typedef ::AlgorithmSimulatedAnnealingType SimulatedAnnealing_type;
    typedef ::xsd::cxx::tree::optional< SimulatedAnnealing_type > SimulatedAnnealing_optional;
    typedef ::xsd::cxx::tree::traits< SimulatedAnnealing_type, char > SimulatedAnnealing_traits;

    const SimulatedAnnealing_optional&
        SimulatedAnnealing() const;

    SimulatedAnnealing_optional&
        SimulatedAnnealing();

    void
        SimulatedAnnealing(const SimulatedAnnealing_type& x);

    void
        SimulatedAnnealing(const SimulatedAnnealing_optional& x);

    void
        SimulatedAnnealing(::std::auto_ptr< SimulatedAnnealing_type > p);

    // LM
    //
    typedef ::LMElementType LM_type;
    typedef ::xsd::cxx::tree::optional< LM_type > LM_optional;
    typedef ::xsd::cxx::tree::traits< LM_type, char > LM_traits;

    const LM_optional&
        LM() const;

    LM_optional&
        LM();

    void
        LM(const LM_type& x);

    void
        LM(const LM_optional& x);

    void
        LM(::std::auto_ptr< LM_type > p);

    // Simplex
    //
    typedef ::SimplexElementType Simplex_type;
    typedef ::xsd::cxx::tree::optional< Simplex_type > Simplex_optional;
    typedef ::xsd::cxx::tree::traits< Simplex_type, char > Simplex_traits;

    const Simplex_optional&
        Simplex() const;

    Simplex_optional&
        Simplex();

    void
        Simplex(const Simplex_type& x);

    void
        Simplex(const Simplex_optional& x);

    void
        Simplex(::std::auto_ptr< Simplex_type > p);

    // Constructors.
    //
    AlgorithmType();

    AlgorithmType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    AlgorithmType(const AlgorithmType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual AlgorithmType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AlgorithmType&
        operator= (const AlgorithmType& x);

    virtual
        ~AlgorithmType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    SimulatedAnnealing_optional SimulatedAnnealing_;
    LM_optional LM_;
    Simplex_optional Simplex_;
};

class MuscleInTheLoopType : public ::xml_schema::type
{
public:
    // trackedMuscles
    //
    typedef ::MuscleListOptimizationType trackedMuscles_type;
    typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

    const trackedMuscles_type&
        trackedMuscles() const;

    trackedMuscles_type&
        trackedMuscles();

    void
        trackedMuscles(const trackedMuscles_type& x);

    void
        trackedMuscles(::std::auto_ptr< trackedMuscles_type > p);

    // optimizedMuscles
    //
    typedef ::MuscleListOptimizationType optimizedMuscles_type;
    typedef ::xsd::cxx::tree::traits< optimizedMuscles_type, char > optimizedMuscles_traits;

    const optimizedMuscles_type&
        optimizedMuscles() const;

    optimizedMuscles_type&
        optimizedMuscles();

    void
        optimizedMuscles(const optimizedMuscles_type& x);

    void
        optimizedMuscles(::std::auto_ptr< optimizedMuscles_type > p);

    // DOFsOptimized
    //
    typedef ::MuscleListOptimizationType DOFsOptimized_type;
    typedef ::xsd::cxx::tree::traits< DOFsOptimized_type, char > DOFsOptimized_traits;

    const DOFsOptimized_type&
        DOFsOptimized() const;

    DOFsOptimized_type&
        DOFsOptimized();

    void
        DOFsOptimized(const DOFsOptimized_type& x);

    void
        DOFsOptimized(::std::auto_ptr< DOFsOptimized_type > p);

    // optimizationCriterion
    //
    typedef ::xml_schema::string optimizationCriterion_type;
    typedef ::xsd::cxx::tree::traits< optimizationCriterion_type, char > optimizationCriterion_traits;

    const optimizationCriterion_type&
        optimizationCriterion() const;

    optimizationCriterion_type&
        optimizationCriterion();

    void
        optimizationCriterion(const optimizationCriterion_type& x);

    void
        optimizationCriterion(::std::auto_ptr< optimizationCriterion_type > p);

    // wheightOptimizedMuscle
    //
    typedef ::xml_schema::double_ wheightOptimizedMuscle_type;
    typedef ::xsd::cxx::tree::traits< wheightOptimizedMuscle_type, char, ::xsd::cxx::tree::schema_type::double_ > wheightOptimizedMuscle_traits;

    const wheightOptimizedMuscle_type&
        wheightOptimizedMuscle() const;

    wheightOptimizedMuscle_type&
        wheightOptimizedMuscle();

    void
        wheightOptimizedMuscle(const wheightOptimizedMuscle_type& x);

    // wheightNonOptimizedMuscle
    //
    typedef ::xml_schema::double_ wheightNonOptimizedMuscle_type;
    typedef ::xsd::cxx::tree::traits< wheightNonOptimizedMuscle_type, char, ::xsd::cxx::tree::schema_type::double_ > wheightNonOptimizedMuscle_traits;

    const wheightNonOptimizedMuscle_type&
        wheightNonOptimizedMuscle() const;

    wheightNonOptimizedMuscle_type&
        wheightNonOptimizedMuscle();

    void
        wheightNonOptimizedMuscle(const wheightNonOptimizedMuscle_type& x);

    // reductionFactor
    //
    typedef ::xml_schema::double_ reductionFactor_type;
    typedef ::xsd::cxx::tree::traits< reductionFactor_type, char, ::xsd::cxx::tree::schema_type::double_ > reductionFactor_traits;

    const reductionFactor_type&
        reductionFactor() const;

    reductionFactor_type&
        reductionFactor();

    void
        reductionFactor(const reductionFactor_type& x);

    // nCyclesRef
    //
    typedef ::xml_schema::int_ nCyclesRef_type;
    typedef ::xsd::cxx::tree::traits< nCyclesRef_type, char > nCyclesRef_traits;

    const nCyclesRef_type&
        nCyclesRef() const;

    nCyclesRef_type&
        nCyclesRef();

    void
        nCyclesRef(const nCyclesRef_type& x);

    // nCyclesOptimization
    //
    typedef ::xml_schema::int_ nCyclesOptimization_type;
    typedef ::xsd::cxx::tree::traits< nCyclesOptimization_type, char > nCyclesOptimization_traits;

    const nCyclesOptimization_type&
        nCyclesOptimization() const;

    nCyclesOptimization_type&
        nCyclesOptimization();

    void
        nCyclesOptimization(const nCyclesOptimization_type& x);

    // Constructors.
    //
    MuscleInTheLoopType(const trackedMuscles_type&,
        const optimizedMuscles_type&,
        const DOFsOptimized_type&,
        const optimizationCriterion_type&,
        const wheightOptimizedMuscle_type&,
        const wheightNonOptimizedMuscle_type&,
        const reductionFactor_type&,
        const nCyclesRef_type&,
        const nCyclesOptimization_type&);

    MuscleInTheLoopType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    MuscleInTheLoopType(const MuscleInTheLoopType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual MuscleInTheLoopType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MuscleInTheLoopType&
        operator= (const MuscleInTheLoopType& x);

    virtual
        ~MuscleInTheLoopType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
    ::xsd::cxx::tree::one< optimizedMuscles_type > optimizedMuscles_;
    ::xsd::cxx::tree::one< DOFsOptimized_type > DOFsOptimized_;
    ::xsd::cxx::tree::one< optimizationCriterion_type > optimizationCriterion_;
    ::xsd::cxx::tree::one< wheightOptimizedMuscle_type > wheightOptimizedMuscle_;
    ::xsd::cxx::tree::one< wheightNonOptimizedMuscle_type > wheightNonOptimizedMuscle_;
    ::xsd::cxx::tree::one< reductionFactor_type > reductionFactor_;
    ::xsd::cxx::tree::one< nCyclesRef_type > nCyclesRef_;
    ::xsd::cxx::tree::one< nCyclesOptimization_type > nCyclesOptimization_;
};

class HybridOptimizationType : public ::xml_schema::type
{
public:
    // alpha
    //
    typedef ::xml_schema::double_ alpha_type;
    typedef ::xsd::cxx::tree::traits< alpha_type, char, ::xsd::cxx::tree::schema_type::double_ > alpha_traits;

    const alpha_type&
        alpha() const;

    alpha_type&
        alpha();

    void
        alpha(const alpha_type& x);

    // beta
    //
    typedef ::xml_schema::double_ beta_type;
    typedef ::xsd::cxx::tree::traits< beta_type, char, ::xsd::cxx::tree::schema_type::double_ > beta_traits;

    const beta_type&
        beta() const;

    beta_type&
        beta();

    void
        beta(const beta_type& x);

    // gamma
    //
    typedef ::xml_schema::double_ gamma_type;
    typedef ::xsd::cxx::tree::traits< gamma_type, char, ::xsd::cxx::tree::schema_type::double_ > gamma_traits;

    const gamma_type&
        gamma() const;

    gamma_type&
        gamma();

    void
        gamma(const gamma_type& x);

    // trackedMuscles
    //
    typedef ::MuscleListOptimizationType trackedMuscles_type;
    typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

    const trackedMuscles_type&
        trackedMuscles() const;

    trackedMuscles_type&
        trackedMuscles();

    void
        trackedMuscles(const trackedMuscles_type& x);

    void
        trackedMuscles(::std::auto_ptr< trackedMuscles_type > p);

    // predictedMuscles
    //
    typedef ::MuscleListOptimizationType predictedMuscles_type;
    typedef ::xsd::cxx::tree::traits< predictedMuscles_type, char > predictedMuscles_traits;

    const predictedMuscles_type&
        predictedMuscles() const;

    predictedMuscles_type&
        predictedMuscles();

    void
        predictedMuscles(const predictedMuscles_type& x);

    void
        predictedMuscles(::std::auto_ptr< predictedMuscles_type > p);

    // DOFsOptimized
    //
    typedef ::MuscleListOptimizationType DOFsOptimized_type;
    typedef ::xsd::cxx::tree::traits< DOFsOptimized_type, char > DOFsOptimized_traits;

    const DOFsOptimized_type&
        DOFsOptimized() const;

    DOFsOptimized_type&
        DOFsOptimized();

    void
        DOFsOptimized(const DOFsOptimized_type& x);

    void
        DOFsOptimized(::std::auto_ptr< DOFsOptimized_type > p);

    // performanceCriterion
    //
    typedef ::xml_schema::string performanceCriterion_type;
    typedef ::xsd::cxx::tree::traits< performanceCriterion_type, char > performanceCriterion_traits;

    const performanceCriterion_type&
        performanceCriterion() const;

    performanceCriterion_type&
        performanceCriterion();

    void
        performanceCriterion(const performanceCriterion_type& x);

    void
        performanceCriterion(::std::auto_ptr< performanceCriterion_type > p);

    // Constructors.
    //
    HybridOptimizationType(const alpha_type&,
        const beta_type&,
        const gamma_type&,
        const trackedMuscles_type&,
        const predictedMuscles_type&,
        const DOFsOptimized_type&,
        const performanceCriterion_type&);

    HybridOptimizationType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    HybridOptimizationType(const HybridOptimizationType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual HybridOptimizationType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    HybridOptimizationType&
        operator= (const HybridOptimizationType& x);

    virtual
        ~HybridOptimizationType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< alpha_type > alpha_;
    ::xsd::cxx::tree::one< beta_type > beta_;
    ::xsd::cxx::tree::one< gamma_type > gamma_;
    ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
    ::xsd::cxx::tree::one< predictedMuscles_type > predictedMuscles_;
    ::xsd::cxx::tree::one< DOFsOptimized_type > DOFsOptimized_;
    ::xsd::cxx::tree::one< performanceCriterion_type > performanceCriterion_;
};

class OnlineCalibrationType : public ::xml_schema::type
{
public:
    // trackedMuscles
    //
    typedef ::MuscleListOptimizationType trackedMuscles_type;
    typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

    const trackedMuscles_type&
        trackedMuscles() const;

    trackedMuscles_type&
        trackedMuscles();

    void
        trackedMuscles(const trackedMuscles_type& x);

    void
        trackedMuscles(::std::auto_ptr< trackedMuscles_type > p);

    // predictedMuscles
    //
    typedef ::MuscleListOptimizationType predictedMuscles_type;
    typedef ::xsd::cxx::tree::traits< predictedMuscles_type, char > predictedMuscles_traits;

    const predictedMuscles_type&
        predictedMuscles() const;

    predictedMuscles_type&
        predictedMuscles();

    void
        predictedMuscles(const predictedMuscles_type& x);

    void
        predictedMuscles(::std::auto_ptr< predictedMuscles_type > p);

    // BufferSize
    //
    typedef ::xml_schema::int_ BufferSize_type;
    typedef ::xsd::cxx::tree::traits< BufferSize_type, char > BufferSize_traits;

    const BufferSize_type&
        BufferSize() const;

    BufferSize_type&
        BufferSize();

    void
        BufferSize(const BufferSize_type& x);

    // Constructors.
    //
    OnlineCalibrationType(const trackedMuscles_type&,
        const predictedMuscles_type&,
        const BufferSize_type&);

    OnlineCalibrationType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    OnlineCalibrationType(const OnlineCalibrationType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual OnlineCalibrationType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OnlineCalibrationType&
        operator= (const OnlineCalibrationType& x);

    virtual
        ~OnlineCalibrationType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
    ::xsd::cxx::tree::one< predictedMuscles_type > predictedMuscles_;
    ::xsd::cxx::tree::one< BufferSize_type > BufferSize_;
};

class MuscleParameterType : public ::xml_schema::type
{
public:
    // trackedMuscles
    //
    typedef ::MuscleListOptimizationType trackedMuscles_type;
    typedef ::xsd::cxx::tree::traits< trackedMuscles_type, char > trackedMuscles_traits;

    const trackedMuscles_type&
        trackedMuscles() const;

    trackedMuscles_type&
        trackedMuscles();

    void
        trackedMuscles(const trackedMuscles_type& x);

    void
        trackedMuscles(::std::auto_ptr< trackedMuscles_type > p);

    // alpha
    //
    typedef ::xml_schema::double_ alpha_type;
    typedef ::xsd::cxx::tree::traits< alpha_type, char, ::xsd::cxx::tree::schema_type::double_ > alpha_traits;

    const alpha_type&
        alpha() const;

    alpha_type&
        alpha();

    void
        alpha(const alpha_type& x);

    // beta
    //
    typedef ::xml_schema::double_ beta_type;
    typedef ::xsd::cxx::tree::traits< beta_type, char, ::xsd::cxx::tree::schema_type::double_ > beta_traits;

    const beta_type&
        beta() const;

    beta_type&
        beta();

    void
        beta(const beta_type& x);

    // gamma
    //
    typedef ::xml_schema::double_ gamma_type;
    typedef ::xsd::cxx::tree::traits< gamma_type, char, ::xsd::cxx::tree::schema_type::double_ > gamma_traits;

    const gamma_type&
        gamma() const;

    gamma_type&
        gamma();

    void
        gamma(const gamma_type& x);

    // MuscleForceTreshold
    //
    typedef ::TresholdType MuscleForceTreshold_type;
    typedef ::xsd::cxx::tree::traits< MuscleForceTreshold_type, char > MuscleForceTreshold_traits;

    const MuscleForceTreshold_type&
        MuscleForceTreshold() const;

    MuscleForceTreshold_type&
        MuscleForceTreshold();

    void
        MuscleForceTreshold(const MuscleForceTreshold_type& x);

    void
        MuscleForceTreshold(::std::auto_ptr< MuscleForceTreshold_type > p);

    // MuscleLengthTreshold
    //
    typedef ::TresholdType MuscleLengthTreshold_type;
    typedef ::xsd::cxx::tree::traits< MuscleLengthTreshold_type, char > MuscleLengthTreshold_traits;

    const MuscleLengthTreshold_type&
        MuscleLengthTreshold() const;

    MuscleLengthTreshold_type&
        MuscleLengthTreshold();

    void
        MuscleLengthTreshold(const MuscleLengthTreshold_type& x);

    void
        MuscleLengthTreshold(::std::auto_ptr< MuscleLengthTreshold_type > p);

    // Constructors.
    //
    MuscleParameterType(const trackedMuscles_type&,
        const alpha_type&,
        const beta_type&,
        const gamma_type&,
        const MuscleForceTreshold_type&,
        const MuscleLengthTreshold_type&);

    MuscleParameterType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    MuscleParameterType(const MuscleParameterType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual MuscleParameterType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MuscleParameterType&
        operator= (const MuscleParameterType& x);

    virtual
        ~MuscleParameterType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< trackedMuscles_type > trackedMuscles_;
    ::xsd::cxx::tree::one< alpha_type > alpha_;
    ::xsd::cxx::tree::one< beta_type > beta_;
    ::xsd::cxx::tree::one< gamma_type > gamma_;
    ::xsd::cxx::tree::one< MuscleForceTreshold_type > MuscleForceTreshold_;
    ::xsd::cxx::tree::one< MuscleLengthTreshold_type > MuscleLengthTreshold_;
};

class OptimizationType : public ::xml_schema::type
{
public:
    // Algorithm
    //
    typedef ::AlgorithmType Algorithm_type;
    typedef ::xsd::cxx::tree::traits< Algorithm_type, char > Algorithm_traits;

    const Algorithm_type&
        Algorithm() const;

    Algorithm_type&
        Algorithm();

    void
        Algorithm(const Algorithm_type& x);

    void
        Algorithm(::std::auto_ptr< Algorithm_type > p);

    // MuscleInTheLoop
    //
    typedef ::MuscleInTheLoopType MuscleInTheLoop_type;
    typedef ::xsd::cxx::tree::optional< MuscleInTheLoop_type > MuscleInTheLoop_optional;
    typedef ::xsd::cxx::tree::traits< MuscleInTheLoop_type, char > MuscleInTheLoop_traits;

    const MuscleInTheLoop_optional&
        MuscleInTheLoop() const;

    MuscleInTheLoop_optional&
        MuscleInTheLoop();

    void
        MuscleInTheLoop(const MuscleInTheLoop_type& x);

    void
        MuscleInTheLoop(const MuscleInTheLoop_optional& x);

    void
        MuscleInTheLoop(::std::auto_ptr< MuscleInTheLoop_type > p);

    // Hybrid
    //
    typedef ::HybridOptimizationType Hybrid_type;
    typedef ::xsd::cxx::tree::optional< Hybrid_type > Hybrid_optional;
    typedef ::xsd::cxx::tree::traits< Hybrid_type, char > Hybrid_traits;

    const Hybrid_optional&
        Hybrid() const;

    Hybrid_optional&
        Hybrid();

    void
        Hybrid(const Hybrid_type& x);

    void
        Hybrid(const Hybrid_optional& x);

    void
        Hybrid(::std::auto_ptr< Hybrid_type > p);

    // OnlineCalibration
    //
    typedef ::OnlineCalibrationType OnlineCalibration_type;
    typedef ::xsd::cxx::tree::optional< OnlineCalibration_type > OnlineCalibration_optional;
    typedef ::xsd::cxx::tree::traits< OnlineCalibration_type, char > OnlineCalibration_traits;

    const OnlineCalibration_optional&
        OnlineCalibration() const;

    OnlineCalibration_optional&
        OnlineCalibration();

    void
        OnlineCalibration(const OnlineCalibration_type& x);

    void
        OnlineCalibration(const OnlineCalibration_optional& x);

    void
        OnlineCalibration(::std::auto_ptr< OnlineCalibration_type > p);

    // MuscleParameter
    //
    typedef ::MuscleParameterType MuscleParameter_type;
    typedef ::xsd::cxx::tree::optional< MuscleParameter_type > MuscleParameter_optional;
    typedef ::xsd::cxx::tree::traits< MuscleParameter_type, char > MuscleParameter_traits;

    const MuscleParameter_optional&
        MuscleParameter() const;

    MuscleParameter_optional&
        MuscleParameter();

    void
        MuscleParameter(const MuscleParameter_type& x);

    void
        MuscleParameter(const MuscleParameter_optional& x);

    void
        MuscleParameter(::std::auto_ptr< MuscleParameter_type > p);

    // Constructors.
    //
    OptimizationType(const Algorithm_type&);

    OptimizationType(::std::auto_ptr< Algorithm_type >);

    OptimizationType(const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    OptimizationType(const OptimizationType& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual OptimizationType*
        _clone(::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OptimizationType&
        operator= (const OptimizationType& x);

    virtual
        ~OptimizationType();

    // Implementation.
    //
protected:
    void
        parse(::xsd::cxx::xml::dom::parser< char >&,
            ::xml_schema::flags);

protected:
    ::xsd::cxx::tree::one< Algorithm_type > Algorithm_;
    MuscleInTheLoop_optional MuscleInTheLoop_;
    Hybrid_optional Hybrid_;
    OnlineCalibration_optional OnlineCalibration_;
    MuscleParameter_optional MuscleParameter_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& uri,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& uri,
    ::xml_schema::error_handler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(const ::std::string& uri,
    ::xercesc::DOMErrorHandler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse std::istream.
//

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xml_schema::error_handler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    ::xercesc::DOMErrorHandler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& id,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& id,
    ::xml_schema::error_handler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::std::istream& is,
    const ::std::string& id,
    ::xercesc::DOMErrorHandler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& is,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& is,
    ::xml_schema::error_handler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::xercesc::InputSource& is,
    ::xercesc::DOMErrorHandler& eh,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::OptimizationType >
optimization(const ::xercesc::DOMDocument& d,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

::std::auto_ptr< ::OptimizationType >
optimization(::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
    ::xml_schema::flags f = 0,
    const ::xml_schema::properties& p = ::xml_schema::properties());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX__EXECUTION_OPTIMIZATION_HXX