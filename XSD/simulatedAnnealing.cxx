// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "simulatedAnnealing.hxx"

// DofCalSequence
//

DofCalSequence::
DofCalSequence ()
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (this)
{
}

DofCalSequence::
DofCalSequence (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x, this)
{
}

DofCalSequence::
DofCalSequence (const DofCalSequence& o,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, this)
{
}

// TrialsSequence
// 

const TrialsSequence::trialName_type& TrialsSequence::
trialName () const
{
  return this->trialName_.get ();
}

TrialsSequence::trialName_type& TrialsSequence::
trialName ()
{
  return this->trialName_.get ();
}

void TrialsSequence::
trialName (const trialName_type& x)
{
  this->trialName_.set (x);
}

void TrialsSequence::
trialName (::std::auto_ptr< trialName_type > x)
{
  this->trialName_.set (x);
}

const TrialsSequence::cropMinTimeFromZero_type& TrialsSequence::
cropMinTimeFromZero () const
{
  return this->cropMinTimeFromZero_.get ();
}

TrialsSequence::cropMinTimeFromZero_type& TrialsSequence::
cropMinTimeFromZero ()
{
  return this->cropMinTimeFromZero_.get ();
}

void TrialsSequence::
cropMinTimeFromZero (const cropMinTimeFromZero_type& x)
{
  this->cropMinTimeFromZero_.set (x);
}

const TrialsSequence::cropMaxTimeFromZero_type& TrialsSequence::
cropMaxTimeFromZero () const
{
  return this->cropMaxTimeFromZero_.get ();
}

TrialsSequence::cropMaxTimeFromZero_type& TrialsSequence::
cropMaxTimeFromZero ()
{
  return this->cropMaxTimeFromZero_.get ();
}

void TrialsSequence::
cropMaxTimeFromZero (const cropMaxTimeFromZero_type& x)
{
  this->cropMaxTimeFromZero_.set (x);
}


// Trials
// 

const Trials::directory_type& Trials::
directory () const
{
  return this->directory_.get ();
}

Trials::directory_type& Trials::
directory ()
{
  return this->directory_.get ();
}

void Trials::
directory (const directory_type& x)
{
  this->directory_.set (x);
}

void Trials::
directory (::std::auto_ptr< directory_type > x)
{
  this->directory_.set (x);
}

const Trials::trial_sequence& Trials::
trial () const
{
  return this->trial_;
}

Trials::trial_sequence& Trials::
trial ()
{
  return this->trial_;
}

void Trials::
trial (const trial_sequence& s)
{
  this->trial_ = s;
}


// PreScaling
// 

const PreScaling::use_type& PreScaling::
use () const
{
  return this->use_.get ();
}

PreScaling::use_type& PreScaling::
use ()
{
  return this->use_.get ();
}

void PreScaling::
use (const use_type& x)
{
  this->use_.set (x);
}

const PreScaling::unscaledOsimFile_type& PreScaling::
unscaledOsimFile () const
{
  return this->unscaledOsimFile_.get ();
}

PreScaling::unscaledOsimFile_type& PreScaling::
unscaledOsimFile ()
{
  return this->unscaledOsimFile_.get ();
}

void PreScaling::
unscaledOsimFile (const unscaledOsimFile_type& x)
{
  this->unscaledOsimFile_.set (x);
}

void PreScaling::
unscaledOsimFile (::std::auto_ptr< unscaledOsimFile_type > x)
{
  this->unscaledOsimFile_.set (x);
}


// ComputeSpline
// 

const ComputeSpline::use_type& ComputeSpline::
use () const
{
  return this->use_.get ();
}

ComputeSpline::use_type& ComputeSpline::
use ()
{
  return this->use_.get ();
}

void ComputeSpline::
use (const use_type& x)
{
  this->use_.set (x);
}

const ComputeSpline::printingOption_optional& ComputeSpline::
printingOption () const
{
  return this->printingOption_;
}

ComputeSpline::printingOption_optional& ComputeSpline::
printingOption ()
{
  return this->printingOption_;
}

void ComputeSpline::
printingOption (const printingOption_type& x)
{
  this->printingOption_.set (x);
}

void ComputeSpline::
printingOption (const printingOption_optional& x)
{
  this->printingOption_ = x;
}

const ComputeSpline::numberOfNode_optional& ComputeSpline::
numberOfNode () const
{
  return this->numberOfNode_;
}

ComputeSpline::numberOfNode_optional& ComputeSpline::
numberOfNode ()
{
  return this->numberOfNode_;
}

void ComputeSpline::
numberOfNode (const numberOfNode_type& x)
{
  this->numberOfNode_.set (x);
}

void ComputeSpline::
numberOfNode (const numberOfNode_optional& x)
{
  this->numberOfNode_ = x;
}


// DofCalibrationSequence
// 

const DofCalibrationSequence::dofs_sequence& DofCalibrationSequence::
dofs () const
{
  return this->dofs_;
}

DofCalibrationSequence::dofs_sequence& DofCalibrationSequence::
dofs ()
{
  return this->dofs_;
}

void DofCalibrationSequence::
dofs (const dofs_sequence& s)
{
  this->dofs_ = s;
}


// OptionCalibration
// 

const OptionCalibration::noEpsilon_type& OptionCalibration::
noEpsilon () const
{
  return this->noEpsilon_.get ();
}

OptionCalibration::noEpsilon_type& OptionCalibration::
noEpsilon ()
{
  return this->noEpsilon_.get ();
}

void OptionCalibration::
noEpsilon (const noEpsilon_type& x)
{
  this->noEpsilon_.set (x);
}

const OptionCalibration::RT_optional& OptionCalibration::
RT () const
{
  return this->RT_;
}

OptionCalibration::RT_optional& OptionCalibration::
RT ()
{
  return this->RT_;
}

void OptionCalibration::
RT (const RT_type& x)
{
  this->RT_.set (x);
}

void OptionCalibration::
RT (const RT_optional& x)
{
  this->RT_ = x;
}

const OptionCalibration::T_optional& OptionCalibration::
T () const
{
  return this->T_;
}

OptionCalibration::T_optional& OptionCalibration::
T ()
{
  return this->T_;
}

void OptionCalibration::
T (const T_type& x)
{
  this->T_.set (x);
}

void OptionCalibration::
T (const T_optional& x)
{
  this->T_ = x;
}

const OptionCalibration::NS_optional& OptionCalibration::
NS () const
{
  return this->NS_;
}

OptionCalibration::NS_optional& OptionCalibration::
NS ()
{
  return this->NS_;
}

void OptionCalibration::
NS (const NS_type& x)
{
  this->NS_.set (x);
}

void OptionCalibration::
NS (const NS_optional& x)
{
  this->NS_ = x;
}

const OptionCalibration::NT_optional& OptionCalibration::
NT () const
{
  return this->NT_;
}

OptionCalibration::NT_optional& OptionCalibration::
NT ()
{
  return this->NT_;
}

void OptionCalibration::
NT (const NT_type& x)
{
  this->NT_.set (x);
}

void OptionCalibration::
NT (const NT_optional& x)
{
  this->NT_ = x;
}

const OptionCalibration::epsilon_type& OptionCalibration::
epsilon () const
{
  return this->epsilon_.get ();
}

OptionCalibration::epsilon_type& OptionCalibration::
epsilon ()
{
  return this->epsilon_.get ();
}

void OptionCalibration::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const OptionCalibration::maxNoEval_type& OptionCalibration::
maxNoEval () const
{
  return this->maxNoEval_.get ();
}

OptionCalibration::maxNoEval_type& OptionCalibration::
maxNoEval ()
{
  return this->maxNoEval_.get ();
}

void OptionCalibration::
maxNoEval (const maxNoEval_type& x)
{
  this->maxNoEval_.set (x);
}


// Calibration
// 

const Calibration::use_type& Calibration::
use () const
{
  return this->use_.get ();
}

Calibration::use_type& Calibration::
use ()
{
  return this->use_.get ();
}

void Calibration::
use (const use_type& x)
{
  this->use_.set (x);
}

const Calibration::objectiveFunction_type& Calibration::
objectiveFunction () const
{
  return this->objectiveFunction_.get ();
}

Calibration::objectiveFunction_type& Calibration::
objectiveFunction ()
{
  return this->objectiveFunction_.get ();
}

void Calibration::
objectiveFunction (const objectiveFunction_type& x)
{
  this->objectiveFunction_.set (x);
}

void Calibration::
objectiveFunction (::std::auto_ptr< objectiveFunction_type > x)
{
  this->objectiveFunction_.set (x);
}

const Calibration::filterEMG_optional& Calibration::
filterEMG () const
{
  return this->filterEMG_;
}

Calibration::filterEMG_optional& Calibration::
filterEMG ()
{
  return this->filterEMG_;
}

void Calibration::
filterEMG (const filterEMG_type& x)
{
  this->filterEMG_.set (x);
}

void Calibration::
filterEMG (const filterEMG_optional& x)
{
  this->filterEMG_ = x;
}

const Calibration::EMD_optional& Calibration::
EMD () const
{
  return this->EMD_;
}

Calibration::EMD_optional& Calibration::
EMD ()
{
  return this->EMD_;
}

void Calibration::
EMD (const EMD_type& x)
{
  this->EMD_.set (x);
}

void Calibration::
EMD (const EMD_optional& x)
{
  this->EMD_ = x;
}

const Calibration::dofToCalibrate_type& Calibration::
dofToCalibrate () const
{
  return this->dofToCalibrate_.get ();
}

Calibration::dofToCalibrate_type& Calibration::
dofToCalibrate ()
{
  return this->dofToCalibrate_.get ();
}

void Calibration::
dofToCalibrate (const dofToCalibrate_type& x)
{
  this->dofToCalibrate_.set (x);
}

void Calibration::
dofToCalibrate (::std::auto_ptr< dofToCalibrate_type > x)
{
  this->dofToCalibrate_.set (x);
}

const Calibration::trials_type& Calibration::
trials () const
{
  return this->trials_.get ();
}

Calibration::trials_type& Calibration::
trials ()
{
  return this->trials_.get ();
}

void Calibration::
trials (const trials_type& x)
{
  this->trials_.set (x);
}

void Calibration::
trials (::std::auto_ptr< trials_type > x)
{
  this->trials_.set (x);
}

const Calibration::option_type& Calibration::
option () const
{
  return this->option_.get ();
}

Calibration::option_type& Calibration::
option ()
{
  return this->option_.get ();
}

void Calibration::
option (const option_type& x)
{
  this->option_.set (x);
}

void Calibration::
option (::std::auto_ptr< option_type > x)
{
  this->option_.set (x);
}

const Calibration::inputSubjectXMLName_type& Calibration::
inputSubjectXMLName () const
{
  return this->inputSubjectXMLName_.get ();
}

Calibration::inputSubjectXMLName_type& Calibration::
inputSubjectXMLName ()
{
  return this->inputSubjectXMLName_.get ();
}

void Calibration::
inputSubjectXMLName (const inputSubjectXMLName_type& x)
{
  this->inputSubjectXMLName_.set (x);
}

void Calibration::
inputSubjectXMLName (::std::auto_ptr< inputSubjectXMLName_type > x)
{
  this->inputSubjectXMLName_.set (x);
}

const Calibration::outputSubjectXMLName_type& Calibration::
outputSubjectXMLName () const
{
  return this->outputSubjectXMLName_.get ();
}

Calibration::outputSubjectXMLName_type& Calibration::
outputSubjectXMLName ()
{
  return this->outputSubjectXMLName_.get ();
}

void Calibration::
outputSubjectXMLName (const outputSubjectXMLName_type& x)
{
  this->outputSubjectXMLName_.set (x);
}

void Calibration::
outputSubjectXMLName (::std::auto_ptr< outputSubjectXMLName_type > x)
{
  this->outputSubjectXMLName_.set (x);
}


// SimulatedAnnealingType
// 

const SimulatedAnnealingType::EMGProccesing_optional& SimulatedAnnealingType::
EMGProccesing () const
{
  return this->EMGProccesing_;
}

SimulatedAnnealingType::EMGProccesing_optional& SimulatedAnnealingType::
EMGProccesing ()
{
  return this->EMGProccesing_;
}

void SimulatedAnnealingType::
EMGProccesing (const EMGProccesing_type& x)
{
  this->EMGProccesing_.set (x);
}

void SimulatedAnnealingType::
EMGProccesing (const EMGProccesing_optional& x)
{
  this->EMGProccesing_ = x;
}

void SimulatedAnnealingType::
EMGProccesing (::std::auto_ptr< EMGProccesing_type > x)
{
  this->EMGProccesing_.set (x);
}

const SimulatedAnnealingType::osimFile_type& SimulatedAnnealingType::
osimFile () const
{
  return this->osimFile_.get ();
}

SimulatedAnnealingType::osimFile_type& SimulatedAnnealingType::
osimFile ()
{
  return this->osimFile_.get ();
}

void SimulatedAnnealingType::
osimFile (const osimFile_type& x)
{
  this->osimFile_.set (x);
}

void SimulatedAnnealingType::
osimFile (::std::auto_ptr< osimFile_type > x)
{
  this->osimFile_.set (x);
}

const SimulatedAnnealingType::subjectXML_type& SimulatedAnnealingType::
subjectXML () const
{
  return this->subjectXML_.get ();
}

SimulatedAnnealingType::subjectXML_type& SimulatedAnnealingType::
subjectXML ()
{
  return this->subjectXML_.get ();
}

void SimulatedAnnealingType::
subjectXML (const subjectXML_type& x)
{
  this->subjectXML_.set (x);
}

void SimulatedAnnealingType::
subjectXML (::std::auto_ptr< subjectXML_type > x)
{
  this->subjectXML_.set (x);
}

const SimulatedAnnealingType::nameOfSubject_type& SimulatedAnnealingType::
nameOfSubject () const
{
  return this->nameOfSubject_.get ();
}

SimulatedAnnealingType::nameOfSubject_type& SimulatedAnnealingType::
nameOfSubject ()
{
  return this->nameOfSubject_.get ();
}

void SimulatedAnnealingType::
nameOfSubject (const nameOfSubject_type& x)
{
  this->nameOfSubject_.set (x);
}

void SimulatedAnnealingType::
nameOfSubject (::std::auto_ptr< nameOfSubject_type > x)
{
  this->nameOfSubject_.set (x);
}

const SimulatedAnnealingType::dofsSpline_type& SimulatedAnnealingType::
dofsSpline () const
{
  return this->dofsSpline_.get ();
}

SimulatedAnnealingType::dofsSpline_type& SimulatedAnnealingType::
dofsSpline ()
{
  return this->dofsSpline_.get ();
}

void SimulatedAnnealingType::
dofsSpline (const dofsSpline_type& x)
{
  this->dofsSpline_.set (x);
}

void SimulatedAnnealingType::
dofsSpline (::std::auto_ptr< dofsSpline_type > x)
{
  this->dofsSpline_.set (x);
}

const SimulatedAnnealingType::computeSpline_type& SimulatedAnnealingType::
computeSpline () const
{
  return this->computeSpline_.get ();
}

SimulatedAnnealingType::computeSpline_type& SimulatedAnnealingType::
computeSpline ()
{
  return this->computeSpline_.get ();
}

void SimulatedAnnealingType::
computeSpline (const computeSpline_type& x)
{
  this->computeSpline_.set (x);
}

void SimulatedAnnealingType::
computeSpline (::std::auto_ptr< computeSpline_type > x)
{
  this->computeSpline_.set (x);
}

const SimulatedAnnealingType::preScaling_optional& SimulatedAnnealingType::
preScaling () const
{
  return this->preScaling_;
}

SimulatedAnnealingType::preScaling_optional& SimulatedAnnealingType::
preScaling ()
{
  return this->preScaling_;
}

void SimulatedAnnealingType::
preScaling (const preScaling_type& x)
{
  this->preScaling_.set (x);
}

void SimulatedAnnealingType::
preScaling (const preScaling_optional& x)
{
  this->preScaling_ = x;
}

void SimulatedAnnealingType::
preScaling (::std::auto_ptr< preScaling_type > x)
{
  this->preScaling_.set (x);
}

const SimulatedAnnealingType::calibration_type& SimulatedAnnealingType::
calibration () const
{
  return this->calibration_.get ();
}

SimulatedAnnealingType::calibration_type& SimulatedAnnealingType::
calibration ()
{
  return this->calibration_.get ();
}

void SimulatedAnnealingType::
calibration (const calibration_type& x)
{
  this->calibration_.set (x);
}

void SimulatedAnnealingType::
calibration (::std::auto_ptr< calibration_type > x)
{
  this->calibration_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// DofCalSequence
//

DofCalSequence::
DofCalSequence (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, this)
{
}

DofCalSequence::
DofCalSequence (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, this)
{
}

DofCalSequence::
DofCalSequence (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, this)
{
}

DofCalSequence* DofCalSequence::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DofCalSequence (*this, f, c);
}

DofCalSequence::
~DofCalSequence ()
{
}

// TrialsSequence
//

TrialsSequence::
TrialsSequence (const trialName_type& trialName,
                const cropMinTimeFromZero_type& cropMinTimeFromZero,
                const cropMaxTimeFromZero_type& cropMaxTimeFromZero)
: ::xml_schema::type (),
  trialName_ (trialName, this),
  cropMinTimeFromZero_ (cropMinTimeFromZero, this),
  cropMaxTimeFromZero_ (cropMaxTimeFromZero, this)
{
}

TrialsSequence::
TrialsSequence (const TrialsSequence& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  trialName_ (x.trialName_, f, this),
  cropMinTimeFromZero_ (x.cropMinTimeFromZero_, f, this),
  cropMaxTimeFromZero_ (x.cropMaxTimeFromZero_, f, this)
{
}

TrialsSequence::
TrialsSequence (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  trialName_ (this),
  cropMinTimeFromZero_ (this),
  cropMaxTimeFromZero_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TrialsSequence::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // trialName
    //
    if (n.name () == "trialName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< trialName_type > r (
        trialName_traits::create (i, f, this));

      if (!trialName_.present ())
      {
        this->trialName_.set (r);
        continue;
      }
    }

    // cropMinTimeFromZero
    //
    if (n.name () == "cropMinTimeFromZero" && n.namespace_ ().empty ())
    {
      if (!cropMinTimeFromZero_.present ())
      {
        this->cropMinTimeFromZero_.set (cropMinTimeFromZero_traits::create (i, f, this));
        continue;
      }
    }

    // cropMaxTimeFromZero
    //
    if (n.name () == "cropMaxTimeFromZero" && n.namespace_ ().empty ())
    {
      if (!cropMaxTimeFromZero_.present ())
      {
        this->cropMaxTimeFromZero_.set (cropMaxTimeFromZero_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!trialName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "trialName",
      "");
  }

  if (!cropMinTimeFromZero_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cropMinTimeFromZero",
      "");
  }

  if (!cropMaxTimeFromZero_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cropMaxTimeFromZero",
      "");
  }
}

TrialsSequence* TrialsSequence::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TrialsSequence (*this, f, c);
}

TrialsSequence& TrialsSequence::
operator= (const TrialsSequence& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->trialName_ = x.trialName_;
    this->cropMinTimeFromZero_ = x.cropMinTimeFromZero_;
    this->cropMaxTimeFromZero_ = x.cropMaxTimeFromZero_;
  }

  return *this;
}

TrialsSequence::
~TrialsSequence ()
{
}

// Trials
//

Trials::
Trials (const directory_type& directory)
: ::xml_schema::type (),
  directory_ (directory, this),
  trial_ (this)
{
}

Trials::
Trials (const Trials& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  directory_ (x.directory_, f, this),
  trial_ (x.trial_, f, this)
{
}

Trials::
Trials (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  directory_ (this),
  trial_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Trials::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // directory
    //
    if (n.name () == "directory" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< directory_type > r (
        directory_traits::create (i, f, this));

      if (!directory_.present ())
      {
        this->directory_.set (r);
        continue;
      }
    }

    // trial
    //
    if (n.name () == "trial" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< trial_type > r (
        trial_traits::create (i, f, this));

      this->trial_.push_back (r);
      continue;
    }

    break;
  }

  if (!directory_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "directory",
      "");
  }
}

Trials* Trials::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Trials (*this, f, c);
}

Trials& Trials::
operator= (const Trials& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->directory_ = x.directory_;
    this->trial_ = x.trial_;
  }

  return *this;
}

Trials::
~Trials ()
{
}

// PreScaling
//

PreScaling::
PreScaling (const use_type& use,
            const unscaledOsimFile_type& unscaledOsimFile)
: ::xml_schema::type (),
  use_ (use, this),
  unscaledOsimFile_ (unscaledOsimFile, this)
{
}

PreScaling::
PreScaling (const PreScaling& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  use_ (x.use_, f, this),
  unscaledOsimFile_ (x.unscaledOsimFile_, f, this)
{
}

PreScaling::
PreScaling (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  use_ (this),
  unscaledOsimFile_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PreScaling::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // use
    //
    if (n.name () == "use" && n.namespace_ ().empty ())
    {
      if (!use_.present ())
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    // unscaledOsimFile
    //
    if (n.name () == "unscaledOsimFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unscaledOsimFile_type > r (
        unscaledOsimFile_traits::create (i, f, this));

      if (!unscaledOsimFile_.present ())
      {
        this->unscaledOsimFile_.set (r);
        continue;
      }
    }

    break;
  }

  if (!use_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "use",
      "");
  }

  if (!unscaledOsimFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unscaledOsimFile",
      "");
  }
}

PreScaling* PreScaling::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PreScaling (*this, f, c);
}

PreScaling& PreScaling::
operator= (const PreScaling& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->use_ = x.use_;
    this->unscaledOsimFile_ = x.unscaledOsimFile_;
  }

  return *this;
}

PreScaling::
~PreScaling ()
{
}

// ComputeSpline
//

ComputeSpline::
ComputeSpline (const use_type& use)
: ::xml_schema::type (),
  use_ (use, this),
  printingOption_ (this),
  numberOfNode_ (this)
{
}

ComputeSpline::
ComputeSpline (const ComputeSpline& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  use_ (x.use_, f, this),
  printingOption_ (x.printingOption_, f, this),
  numberOfNode_ (x.numberOfNode_, f, this)
{
}

ComputeSpline::
ComputeSpline (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  use_ (this),
  printingOption_ (this),
  numberOfNode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ComputeSpline::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // use
    //
    if (n.name () == "use" && n.namespace_ ().empty ())
    {
      if (!use_.present ())
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    // printingOption
    //
    if (n.name () == "printingOption" && n.namespace_ ().empty ())
    {
      if (!this->printingOption_)
      {
        this->printingOption_.set (printingOption_traits::create (i, f, this));
        continue;
      }
    }

    // numberOfNode
    //
    if (n.name () == "numberOfNode" && n.namespace_ ().empty ())
    {
      if (!this->numberOfNode_)
      {
        this->numberOfNode_.set (numberOfNode_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!use_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "use",
      "");
  }
}

ComputeSpline* ComputeSpline::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComputeSpline (*this, f, c);
}

ComputeSpline& ComputeSpline::
operator= (const ComputeSpline& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->use_ = x.use_;
    this->printingOption_ = x.printingOption_;
    this->numberOfNode_ = x.numberOfNode_;
  }

  return *this;
}

ComputeSpline::
~ComputeSpline ()
{
}

// DofCalibrationSequence
//

DofCalibrationSequence::
DofCalibrationSequence ()
: ::xml_schema::type (),
  dofs_ (this)
{
}

DofCalibrationSequence::
DofCalibrationSequence (const DofCalibrationSequence& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  dofs_ (x.dofs_, f, this)
{
}

DofCalibrationSequence::
DofCalibrationSequence (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  dofs_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DofCalibrationSequence::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // dofs
    //
    if (n.name () == "dofs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dofs_type > r (
        dofs_traits::create (i, f, this));

      this->dofs_.push_back (r);
      continue;
    }

    break;
  }
}

DofCalibrationSequence* DofCalibrationSequence::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DofCalibrationSequence (*this, f, c);
}

DofCalibrationSequence& DofCalibrationSequence::
operator= (const DofCalibrationSequence& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->dofs_ = x.dofs_;
  }

  return *this;
}

DofCalibrationSequence::
~DofCalibrationSequence ()
{
}

// OptionCalibration
//

OptionCalibration::
OptionCalibration (const noEpsilon_type& noEpsilon,
                   const epsilon_type& epsilon,
                   const maxNoEval_type& maxNoEval)
: ::xml_schema::type (),
  noEpsilon_ (noEpsilon, this),
  RT_ (this),
  T_ (this),
  NS_ (this),
  NT_ (this),
  epsilon_ (epsilon, this),
  maxNoEval_ (maxNoEval, this)
{
}

OptionCalibration::
OptionCalibration (const OptionCalibration& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  noEpsilon_ (x.noEpsilon_, f, this),
  RT_ (x.RT_, f, this),
  T_ (x.T_, f, this),
  NS_ (x.NS_, f, this),
  NT_ (x.NT_, f, this),
  epsilon_ (x.epsilon_, f, this),
  maxNoEval_ (x.maxNoEval_, f, this)
{
}

OptionCalibration::
OptionCalibration (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  noEpsilon_ (this),
  RT_ (this),
  T_ (this),
  NS_ (this),
  NT_ (this),
  epsilon_ (this),
  maxNoEval_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OptionCalibration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // noEpsilon
    //
    if (n.name () == "noEpsilon" && n.namespace_ ().empty ())
    {
      if (!noEpsilon_.present ())
      {
        this->noEpsilon_.set (noEpsilon_traits::create (i, f, this));
        continue;
      }
    }

    // RT
    //
    if (n.name () == "RT" && n.namespace_ ().empty ())
    {
      if (!this->RT_)
      {
        this->RT_.set (RT_traits::create (i, f, this));
        continue;
      }
    }

    // T
    //
    if (n.name () == "T" && n.namespace_ ().empty ())
    {
      if (!this->T_)
      {
        this->T_.set (T_traits::create (i, f, this));
        continue;
      }
    }

    // NS
    //
    if (n.name () == "NS" && n.namespace_ ().empty ())
    {
      if (!this->NS_)
      {
        this->NS_.set (NS_traits::create (i, f, this));
        continue;
      }
    }

    // NT
    //
    if (n.name () == "NT" && n.namespace_ ().empty ())
    {
      if (!this->NT_)
      {
        this->NT_.set (NT_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // maxNoEval
    //
    if (n.name () == "maxNoEval" && n.namespace_ ().empty ())
    {
      if (!maxNoEval_.present ())
      {
        this->maxNoEval_.set (maxNoEval_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!noEpsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "noEpsilon",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!maxNoEval_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxNoEval",
      "");
  }
}

OptionCalibration* OptionCalibration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OptionCalibration (*this, f, c);
}

OptionCalibration& OptionCalibration::
operator= (const OptionCalibration& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->noEpsilon_ = x.noEpsilon_;
    this->RT_ = x.RT_;
    this->T_ = x.T_;
    this->NS_ = x.NS_;
    this->NT_ = x.NT_;
    this->epsilon_ = x.epsilon_;
    this->maxNoEval_ = x.maxNoEval_;
  }

  return *this;
}

OptionCalibration::
~OptionCalibration ()
{
}

// Calibration
//

Calibration::
Calibration (const use_type& use,
             const objectiveFunction_type& objectiveFunction,
             const dofToCalibrate_type& dofToCalibrate,
             const trials_type& trials,
             const option_type& option,
             const inputSubjectXMLName_type& inputSubjectXMLName,
             const outputSubjectXMLName_type& outputSubjectXMLName)
: ::xml_schema::type (),
  use_ (use, this),
  objectiveFunction_ (objectiveFunction, this),
  filterEMG_ (this),
  EMD_ (this),
  dofToCalibrate_ (dofToCalibrate, this),
  trials_ (trials, this),
  option_ (option, this),
  inputSubjectXMLName_ (inputSubjectXMLName, this),
  outputSubjectXMLName_ (outputSubjectXMLName, this)
{
}

Calibration::
Calibration (const use_type& use,
             const objectiveFunction_type& objectiveFunction,
             ::std::auto_ptr< dofToCalibrate_type > dofToCalibrate,
             ::std::auto_ptr< trials_type > trials,
             ::std::auto_ptr< option_type > option,
             const inputSubjectXMLName_type& inputSubjectXMLName,
             const outputSubjectXMLName_type& outputSubjectXMLName)
: ::xml_schema::type (),
  use_ (use, this),
  objectiveFunction_ (objectiveFunction, this),
  filterEMG_ (this),
  EMD_ (this),
  dofToCalibrate_ (dofToCalibrate, this),
  trials_ (trials, this),
  option_ (option, this),
  inputSubjectXMLName_ (inputSubjectXMLName, this),
  outputSubjectXMLName_ (outputSubjectXMLName, this)
{
}

Calibration::
Calibration (const Calibration& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  use_ (x.use_, f, this),
  objectiveFunction_ (x.objectiveFunction_, f, this),
  filterEMG_ (x.filterEMG_, f, this),
  EMD_ (x.EMD_, f, this),
  dofToCalibrate_ (x.dofToCalibrate_, f, this),
  trials_ (x.trials_, f, this),
  option_ (x.option_, f, this),
  inputSubjectXMLName_ (x.inputSubjectXMLName_, f, this),
  outputSubjectXMLName_ (x.outputSubjectXMLName_, f, this)
{
}

Calibration::
Calibration (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  use_ (this),
  objectiveFunction_ (this),
  filterEMG_ (this),
  EMD_ (this),
  dofToCalibrate_ (this),
  trials_ (this),
  option_ (this),
  inputSubjectXMLName_ (this),
  outputSubjectXMLName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Calibration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // use
    //
    if (n.name () == "use" && n.namespace_ ().empty ())
    {
      if (!use_.present ())
      {
        this->use_.set (use_traits::create (i, f, this));
        continue;
      }
    }

    // objectiveFunction
    //
    if (n.name () == "objectiveFunction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< objectiveFunction_type > r (
        objectiveFunction_traits::create (i, f, this));

      if (!objectiveFunction_.present ())
      {
        this->objectiveFunction_.set (r);
        continue;
      }
    }

    // filterEMG
    //
    if (n.name () == "filterEMG" && n.namespace_ ().empty ())
    {
      if (!this->filterEMG_)
      {
        this->filterEMG_.set (filterEMG_traits::create (i, f, this));
        continue;
      }
    }

    // EMD
    //
    if (n.name () == "EMD" && n.namespace_ ().empty ())
    {
      if (!this->EMD_)
      {
        this->EMD_.set (EMD_traits::create (i, f, this));
        continue;
      }
    }

    // dofToCalibrate
    //
    if (n.name () == "dofToCalibrate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dofToCalibrate_type > r (
        dofToCalibrate_traits::create (i, f, this));

      if (!dofToCalibrate_.present ())
      {
        this->dofToCalibrate_.set (r);
        continue;
      }
    }

    // trials
    //
    if (n.name () == "trials" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< trials_type > r (
        trials_traits::create (i, f, this));

      if (!trials_.present ())
      {
        this->trials_.set (r);
        continue;
      }
    }

    // option
    //
    if (n.name () == "option" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< option_type > r (
        option_traits::create (i, f, this));

      if (!option_.present ())
      {
        this->option_.set (r);
        continue;
      }
    }

    // inputSubjectXMLName
    //
    if (n.name () == "inputSubjectXMLName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputSubjectXMLName_type > r (
        inputSubjectXMLName_traits::create (i, f, this));

      if (!inputSubjectXMLName_.present ())
      {
        this->inputSubjectXMLName_.set (r);
        continue;
      }
    }

    // outputSubjectXMLName
    //
    if (n.name () == "outputSubjectXMLName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outputSubjectXMLName_type > r (
        outputSubjectXMLName_traits::create (i, f, this));

      if (!outputSubjectXMLName_.present ())
      {
        this->outputSubjectXMLName_.set (r);
        continue;
      }
    }

    break;
  }

  if (!use_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "use",
      "");
  }

  if (!objectiveFunction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objectiveFunction",
      "");
  }

  if (!dofToCalibrate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dofToCalibrate",
      "");
  }

  if (!trials_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "trials",
      "");
  }

  if (!option_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "option",
      "");
  }

  if (!inputSubjectXMLName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inputSubjectXMLName",
      "");
  }

  if (!outputSubjectXMLName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputSubjectXMLName",
      "");
  }
}

Calibration* Calibration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Calibration (*this, f, c);
}

Calibration& Calibration::
operator= (const Calibration& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->use_ = x.use_;
    this->objectiveFunction_ = x.objectiveFunction_;
    this->filterEMG_ = x.filterEMG_;
    this->EMD_ = x.EMD_;
    this->dofToCalibrate_ = x.dofToCalibrate_;
    this->trials_ = x.trials_;
    this->option_ = x.option_;
    this->inputSubjectXMLName_ = x.inputSubjectXMLName_;
    this->outputSubjectXMLName_ = x.outputSubjectXMLName_;
  }

  return *this;
}

Calibration::
~Calibration ()
{
}

// SimulatedAnnealingType
//

SimulatedAnnealingType::
SimulatedAnnealingType (const osimFile_type& osimFile,
                        const subjectXML_type& subjectXML,
                        const nameOfSubject_type& nameOfSubject,
                        const dofsSpline_type& dofsSpline,
                        const computeSpline_type& computeSpline,
                        const calibration_type& calibration)
: ::xml_schema::type (),
  EMGProccesing_ (this),
  osimFile_ (osimFile, this),
  subjectXML_ (subjectXML, this),
  nameOfSubject_ (nameOfSubject, this),
  dofsSpline_ (dofsSpline, this),
  computeSpline_ (computeSpline, this),
  preScaling_ (this),
  calibration_ (calibration, this)
{
}

SimulatedAnnealingType::
SimulatedAnnealingType (const osimFile_type& osimFile,
                        const subjectXML_type& subjectXML,
                        const nameOfSubject_type& nameOfSubject,
                        const dofsSpline_type& dofsSpline,
                        ::std::auto_ptr< computeSpline_type > computeSpline,
                        ::std::auto_ptr< calibration_type > calibration)
: ::xml_schema::type (),
  EMGProccesing_ (this),
  osimFile_ (osimFile, this),
  subjectXML_ (subjectXML, this),
  nameOfSubject_ (nameOfSubject, this),
  dofsSpline_ (dofsSpline, this),
  computeSpline_ (computeSpline, this),
  preScaling_ (this),
  calibration_ (calibration, this)
{
}

SimulatedAnnealingType::
SimulatedAnnealingType (const SimulatedAnnealingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  EMGProccesing_ (x.EMGProccesing_, f, this),
  osimFile_ (x.osimFile_, f, this),
  subjectXML_ (x.subjectXML_, f, this),
  nameOfSubject_ (x.nameOfSubject_, f, this),
  dofsSpline_ (x.dofsSpline_, f, this),
  computeSpline_ (x.computeSpline_, f, this),
  preScaling_ (x.preScaling_, f, this),
  calibration_ (x.calibration_, f, this)
{
}

SimulatedAnnealingType::
SimulatedAnnealingType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  EMGProccesing_ (this),
  osimFile_ (this),
  subjectXML_ (this),
  nameOfSubject_ (this),
  dofsSpline_ (this),
  computeSpline_ (this),
  preScaling_ (this),
  calibration_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SimulatedAnnealingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // EMGProccesing
    //
    if (n.name () == "EMGProccesing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EMGProccesing_type > r (
        EMGProccesing_traits::create (i, f, this));

      if (!this->EMGProccesing_)
      {
        this->EMGProccesing_.set (r);
        continue;
      }
    }

    // osimFile
    //
    if (n.name () == "osimFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< osimFile_type > r (
        osimFile_traits::create (i, f, this));

      if (!osimFile_.present ())
      {
        this->osimFile_.set (r);
        continue;
      }
    }

    // subjectXML
    //
    if (n.name () == "subjectXML" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< subjectXML_type > r (
        subjectXML_traits::create (i, f, this));

      if (!subjectXML_.present ())
      {
        this->subjectXML_.set (r);
        continue;
      }
    }

    // nameOfSubject
    //
    if (n.name () == "nameOfSubject" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nameOfSubject_type > r (
        nameOfSubject_traits::create (i, f, this));

      if (!nameOfSubject_.present ())
      {
        this->nameOfSubject_.set (r);
        continue;
      }
    }

    // dofsSpline
    //
    if (n.name () == "dofsSpline" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dofsSpline_type > r (
        dofsSpline_traits::create (i, f, this));

      if (!dofsSpline_.present ())
      {
        this->dofsSpline_.set (r);
        continue;
      }
    }

    // computeSpline
    //
    if (n.name () == "computeSpline" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< computeSpline_type > r (
        computeSpline_traits::create (i, f, this));

      if (!computeSpline_.present ())
      {
        this->computeSpline_.set (r);
        continue;
      }
    }

    // preScaling
    //
    if (n.name () == "preScaling" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< preScaling_type > r (
        preScaling_traits::create (i, f, this));

      if (!this->preScaling_)
      {
        this->preScaling_.set (r);
        continue;
      }
    }

    // calibration
    //
    if (n.name () == "calibration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calibration_type > r (
        calibration_traits::create (i, f, this));

      if (!calibration_.present ())
      {
        this->calibration_.set (r);
        continue;
      }
    }

    break;
  }

  if (!osimFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "osimFile",
      "");
  }

  if (!subjectXML_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "subjectXML",
      "");
  }

  if (!nameOfSubject_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nameOfSubject",
      "");
  }

  if (!dofsSpline_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dofsSpline",
      "");
  }

  if (!computeSpline_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "computeSpline",
      "");
  }

  if (!calibration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calibration",
      "");
  }
}

SimulatedAnnealingType* SimulatedAnnealingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimulatedAnnealingType (*this, f, c);
}

SimulatedAnnealingType& SimulatedAnnealingType::
operator= (const SimulatedAnnealingType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->EMGProccesing_ = x.EMGProccesing_;
    this->osimFile_ = x.osimFile_;
    this->subjectXML_ = x.subjectXML_;
    this->nameOfSubject_ = x.nameOfSubject_;
    this->dofsSpline_ = x.dofsSpline_;
    this->computeSpline_ = x.computeSpline_;
    this->preScaling_ = x.preScaling_;
    this->calibration_ = x.calibration_;
  }

  return *this;
}

SimulatedAnnealingType::
~SimulatedAnnealingType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulatedAnnealing (isrc, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulatedAnnealing (isrc, h, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulatedAnnealing (isrc, h, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulatedAnnealing (isrc, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulatedAnnealing (isrc, h, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulatedAnnealing (isrc, h, f, p);
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SimulatedAnnealingType > (
    ::simulatedAnnealing (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SimulatedAnnealingType > (
      ::simulatedAnnealing (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulatedAnnealing" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SimulatedAnnealingType > r (
      ::xsd::cxx::tree::traits< ::SimulatedAnnealingType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulatedAnnealing",
    "");
}

::std::auto_ptr< ::SimulatedAnnealingType >
simulatedAnnealing (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulatedAnnealing" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SimulatedAnnealingType > r (
      ::xsd::cxx::tree::traits< ::SimulatedAnnealingType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulatedAnnealing",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

